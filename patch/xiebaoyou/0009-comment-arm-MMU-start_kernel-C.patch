From 40bcd006c9c0746634c6b5a3145feae1885587fa Mon Sep 17 00:00:00 2001
From: "xie.baoyou" <scxby@163.com>
Date: Thu, 12 Nov 2015 10:25:03 +0800
Subject: [PATCH] =?UTF-8?q?[comment-arm]=20=E8=AE=BE=E7=BD=AEMMU=E5=B9=B6?=
 =?UTF-8?q?=E4=B8=BAstart=5Fkernel=E5=87=BD=E6=95=B0=E5=87=86=E5=A4=87C?=
 =?UTF-8?q?=E8=BF=90=E8=A1=8C=E7=8E=AF=E5=A2=83?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 arch/arm/kernel/head-common.S | 78 +++++++++++++++++++++++++++++++++-
 arch/arm/kernel/head.S        | 80 +++++++++++++++++++++++++++++++++++
 arch/arm/mm/proc-v7.S         |  6 +++
 3 files changed, 162 insertions(+), 2 deletions(-)

diff --git a/arch/arm/kernel/head-common.S b/arch/arm/kernel/head-common.S
index 8733012d..99bb45e9 100644
--- a/arch/arm/kernel/head-common.S
+++ b/arch/arm/kernel/head-common.S
@@ -44,10 +44,19 @@
  *  r2 either valid atags pointer, valid dtb pointer, or zero
  *  r5, r6 corrupted
  */
+/**
+ * 检查BOOT传入的ATAGS是否合法，ATAGS被BOOT中的setup_start_tag函数设置。
+ */
 __vet_atags:
+/**
+ * 检查atags是否四字节对齐，不对齐的话直接返回错误
+ */
 	tst	r2, #0x3			@ aligned?
 	bne	1f
 
+/**
+ * 读入其长度，如果其长度不等于ATAG_CORE_SIZE，表示存储的内容不是ATAG
+ */
 	ldr	r5, [r2, #0]
 #ifdef CONFIG_OF_FLATTREE
 	ldr	r6, =OF_DT_MAGIC		@ is it a DTB?
@@ -57,6 +66,9 @@ __vet_atags:
 	cmp	r5, #ATAG_CORE_SIZE		@ is first tag ATAG_CORE?
 	cmpne	r5, #ATAG_CORE_SIZE_EMPTY
 	bne	1f
+/**
+ * 判断其标志是否是ATAG_CORE，第一个元素必须是此类型
+ */
 	ldr	r5, [r2, #4]
 	ldr	r6, =ATAG_CORE
 	cmp	r5, r6
@@ -78,29 +90,66 @@ ENDPROC(__vet_atags)
  *  r9  = processor ID
  */
 	__INIT
+/**
+ * 从这里开始，代码运行在MMU地址空间中。以绝对地址的方式执行，不必用PIC方式执行了。
+ * 为start_kernel准备C运行环境。
+ */
 __mmap_switched:
+/**
+ * 计算PC相对于__mmap_switched_data地址的差异，计算PC减去相对地址的结果。
+ * 这里可以不用这种PIC的方式，但是这样做应该可以节约一条指令。
+ */
 	adr	r3, __mmap_switched_data
 
+/**
+ * 从__mmap_switched_data加载__data_loc，_data，__bss_start，__end变量到寄存器中
+ */
 	ldmia	r3!, {r4, r5, r6, r7}
+/**
+ * __data_loc指向二进制文件中初始化数据的起始位置，__data指向内存中初始化数据的起始位置
+ * 二者一般相等，也许XIP方式下二者会不相等。
+ */
 	cmp	r4, r5				@ Copy data segment if needed
+/**
+ * _data，__bss_start二者之间即为初始化数据，遍历复制它
+ */
 1:	cmpne	r5, r6
 	ldrne	fp, [r4], #4
 	strne	fp, [r5], #4
 	bne	1b
 
+/**
+ * 清空BSS段
+ */
 	mov	fp, #0				@ Clear BSS (and zero fp)
 1:	cmp	r6, r7
 	strcc	fp, [r6],#4
 	bcc	1b
 
+/**
+ * 前面的ldmia指令加了！，因此此时r3已经指向processor_id字段
+ * 注意这里将init进程的SP指针读入到SP寄存器了。
+ */
  ARM(	ldmia	r3, {r4, r5, r6, r7, sp})
  THUMB(	ldmia	r3, {r4, r5, r6, r7}	)
  THUMB(	ldr	sp, [r3, #16]		)
+ /**
+  * 存储处理器ID到全局processor_id变量中
+  */
 	str	r9, [r4]			@ Save processor ID
+/**
+ * 存储机器类型到__machine_arch_type字段
+ */
 	str	r1, [r5]			@ Save machine type
+/**
+ * 存储atags指针
+ */
 	str	r2, [r6]			@ Save atags pointer
 	cmp	r7, #0
 	strne	r0, [r7]			@ Save control register values
+/**
+ * 跳转到C运行环境，是不是想深呼吸一下:)
+ */
 	b	start_kernel
 ENDPROC(__mmap_switched)
 
@@ -149,20 +198,45 @@ ENDPROC(lookup_processor_type)
  *	r5 = proc_info pointer in physical address space
  *	r9 = cpuid (preserved)
  */
+/**
+ * 查找处理器类型，在汇编语言中直接调用
+ * 在r9中保存的是CPUID
+ */
 __lookup_processor_type:
+/**
+ * 加载procinfo起始地址到r3中
+ */
 	adr	r3, __lookup_processor_type_data
-	ldmia	r3, {r4 - r6}
+/**
+ * 将proc info加载到临时寄存器中
+ */
+	ldmia	r3, {r4 - r6}	@ r4-r6中保存的是物理地址
+/**
+ * 计算物理地址和虚拟之间的差异
+ */
 	sub	r3, r3, r4			@ get offset between virt&phys
+/**
+ * 将proc begin和proc end转换为物理地址
+ */
 	add	r5, r5, r3			@ convert virt addresses to
 	add	r6, r6, r3			@ physical address space
+/**
+ * 循环查找匹配的proc
+ */
 1:	ldmia	r5, {r3, r4}			@ value, mask
 	and	r4, r4, r9			@ mask wanted bits
-	teq	r3, r4
+	teq	r3, r4				@ 匹配成功即退出
 	beq	2f
 	add	r5, r5, #PROC_INFO_SZ		@ sizeof(proc_info_list)
 	cmp	r5, r6
 	blo	1b
+/**
+ * 无法识别的CPU
+ */
 	mov	r5, #0				@ unknown processor
+/**
+ * 在初始化时，lr中保存的地址是:b __enable_mmu
+ */
 2:	ret	lr
 ENDPROC(__lookup_processor_type)
 
diff --git a/arch/arm/kernel/head.S b/arch/arm/kernel/head.S
index 04286fd9..d5dd80d7 100644
--- a/arch/arm/kernel/head.S
+++ b/arch/arm/kernel/head.S
@@ -89,12 +89,24 @@ ENTRY(stext)
 	bl	__hyp_stub_install
 #endif
 	@ ensure svc mode and all interrupts masked
+/**
+ * 进入SVC状态，并屏蔽所有中断
+ */
 	safe_svcmode_maskall r9
 
+/**
+ * 获得处理器ID
+ */
 	mrc	p15, 0, r9, c0, c0		@ get processor id
+/**
+ * 在procinfo中，根据CPUID查找对应的proc
+ */
 	bl	__lookup_processor_type		@ r5=procinfo r9=cpuid
 	movs	r10, r5				@ invalid processor (r5=0)?
  THUMB( it	eq )		@ force fixup-able long branch encoding
+ /**
+  * CPUID与proc不匹配，只好打印错误信息并停止了
+  */
 	beq	__error_p			@ yes, error 'p'
 
 #ifdef CONFIG_ARM_LPAE
@@ -146,8 +158,14 @@ ENTRY(stext)
 	 * r0 will hold the CPU control register value, r1, r2, r4, and
 	 * r9 will be preserved.  r5 will also be preserved if LPAE.
 	 */
+/**
+ * 启用MMU后，会调用__mmap_switched
+ */
 	ldr	r13, =__mmap_switched		@ address to jump to after
 						@ mmu has been enabled
+/**
+ * 返回地址，调用procinfo中的初始化函数后执行__enable_mmu
+ */
 	badr	lr, 1f				@ return (PIC) address
 #ifdef CONFIG_ARM_LPAE
 	mov	r5, #0				@ high TTBR0
@@ -155,8 +173,15 @@ ENTRY(stext)
 #else
 	mov	r8, r4				@ set TTBR1 to swapper_pg_dir
 #endif
+/**
+ * r10中保存了procinfo，调用它的init函数
+ * 对V7来说，调用的是__v7_setup
+ */
 	ldr	r12, [r10, #PROCINFO_INITFUNC]
 	add	r12, r12, r10
+/**
+ * 返回后，会执行lr中保存的返回地址，即1f，调用__enable_mmu
+ */
 	ret	r12
 1:	b	__enable_mmu
 ENDPROC(stext)
@@ -177,7 +202,13 @@ ENDPROC(stext)
  *  r0, r3, r5-r7 corrupted
  *  r4 = physical page table address
  */
+/**
+ * 设置内核初始页表项
+ */
 __create_page_tables:
+/**
+ * 设置r4为内核页表起始地址，物理地址:内核代码段起始位置前移0x4000
+ */
 	pgtbl	r4, r8				@ page table address
 
 	/*
@@ -185,7 +216,13 @@ __create_page_tables:
 	 */
 	mov	r0, r4
 	mov	r3, #0
+/**
+ * 页表项长度
+ */
 	add	r6, r0, #PG_DIR_SIZE
+/**
+ * 遍历请空页表项
+ */
 1:	str	r3, [r0], #4
 	str	r3, [r0], #4
 	str	r3, [r0], #4
@@ -221,6 +258,9 @@ __create_page_tables:
 #endif
 #endif
 
+/**
+ * 从procinfo中读取mmuflags
+ */
 	ldr	r7, [r10, #PROCINFO_MM_MMUFLAGS] @ mm_mmuflags
 
 	/*
@@ -446,28 +486,55 @@ __secondary_data:
  *  r9  = processor ID
  *  r13 = *virtual* address to jump to upon completion
  */
+/**
+ * 启用MMU，r13中保存的是__mmap_switched
+ */
 __enable_mmu:
+/**
+ * 设置CR_A位，该位控制alignment_abort异常
+ */
 #if defined(CONFIG_ALIGNMENT_TRAP) && __LINUX_ARM_ARCH__ < 6
 	orr	r0, r0, #CR_A
 #else
 	bic	r0, r0, #CR_A
 #endif
+/**
+ * 设置数据缓存控制位
+ */
 #ifdef CONFIG_CPU_DCACHE_DISABLE
 	bic	r0, r0, #CR_C
 #endif
+/**
+ * 禁用分支预测
+ */
 #ifdef CONFIG_CPU_BPREDICT_DISABLE
 	bic	r0, r0, #CR_Z
 #endif
+/**
+ * 禁用指令cache
+ */
 #ifdef CONFIG_CPU_ICACHE_DISABLE
 	bic	r0, r0, #CR_I
 #endif
 #ifdef CONFIG_ARM_LPAE
 	mcrr	p15, 0, r4, r5, c2		@ load TTBR0
 #else
+/**
+ * 设置域，用于控制不同模式下能访问的虚拟地址空间范围
+ */
 	mov	r5, #DACR_INIT
+/**
+ * 将域设置字段加载到CP15的C3寄存器
+ */
 	mcr	p15, 0, r5, c3, c0, 0		@ load domain access register
+/**
+ * 加载页表转换表指针到CP15寄存器
+ */
 	mcr	p15, 0, r4, c2, c0, 0		@ load page table pointer
 #endif
+/**
+ * 打开MMU
+ */
 	b	__turn_mmu_on
 ENDPROC(__enable_mmu)
 
@@ -488,12 +555,25 @@ ENDPROC(__enable_mmu)
 	.align	5
 	.pushsection	.idmap.text, "ax"
 ENTRY(__turn_mmu_on)
+/**
+ * r0中已经包含MMU硬件相关的位了
+ */
 	mov	r0, r0
 	instr_sync
+/**
+ * 将其写入控制器寄存器c1，激活MMU
+ */
 	mcr	p15, 0, r0, c1, c0, 0		@ write control reg
 	mrc	p15, 0, r3, c0, c0, 0		@ read id reg
 	instr_sync
+/**
+ * 这条指令相当于NOP指令，刚切换了MMU，必须在CPU流水线中放这样的指令
+ */
 	mov	r3, r3
+/**
+ * r13中保存的是__mmap_switched函数的地址，跳过去执行吧。
+ * 开启MMU之旅:)
+ */
 	mov	r3, r13
 	ret	r3
 __turn_mmu_on_end:
diff --git a/arch/arm/mm/proc-v7.S b/arch/arm/mm/proc-v7.S
index de2b246f..533e7286 100644
--- a/arch/arm/mm/proc-v7.S
+++ b/arch/arm/mm/proc-v7.S
@@ -414,6 +414,9 @@ __v7_pj4b_setup:
 
 #endif /* CONFIG_CPU_PJ4B */
 
+/**
+ * 在创建初始页表后，调用此函数进行处理器初始化。
+ */
 __v7_setup:
 	adr	r12, __v7_setup_stack		@ the local stack
 	stmia	r12, {r0-r5, lr}		@ v7_invalidate_l1 touches r0-r6
@@ -479,6 +482,9 @@ __errata_finish:
 	bic	r0, r0, r3			@ clear bits them
 	orr	r0, r0, r6			@ set them
  THUMB(	orr	r0, r0, #1 << 30	)	@ Thumb exceptions
+ /**
+  * 返回到head.S:__enable_mmu
+  */
 	ret	lr				@ return to head.S:__ret
 ENDPROC(__v7_setup)
 
-- 
2.25.1

