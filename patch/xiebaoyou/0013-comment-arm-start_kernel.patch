From 60968a98b41ae7fd579645047a36017f24a41b3e Mon Sep 17 00:00:00 2001
From: "xie.baoyou" <scxby@163.com>
Date: Fri, 13 Nov 2015 19:39:29 +0800
Subject: [PATCH] =?UTF-8?q?[comment-arm]=20start=5Fkernel=E7=AC=AC?=
 =?UTF-8?q?=E5=9B=9B=E9=83=A8=E5=88=86?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 arch/arm/mm/init.c   | 21 +++++++++++++++++----
 init/main.c          |  8 ++++++++
 kernel/sched/core.c  |  4 ++++
 kernel/sched/sched.h |  4 ++++
 mm/page_alloc.c      | 19 +++++++++++++++++++
 5 files changed, 52 insertions(+), 4 deletions(-)

diff --git a/arch/arm/mm/init.c b/arch/arm/mm/init.c
index 8a63b4cd..db241284 100644
--- a/arch/arm/mm/init.c
+++ b/arch/arm/mm/init.c
@@ -149,6 +149,7 @@ static void __init zone_sizes_init(unsigned long min, unsigned long max_low,
 	 * to do anything fancy with the allocation of this memory
 	 * to the zones, now is the time to do it.
 	 */
+	//第一个和高端内存zone的大小
 	zone_size[0] = max_low - min;
 #ifdef CONFIG_HIGHMEM
 	zone_size[ZONE_HIGHMEM] = max_high - max_low;
@@ -158,17 +159,17 @@ static void __init zone_sizes_init(unsigned long min, unsigned long max_low,
 	 * Calculate the size of the holes.
 	 *  holes = node_size - sum(bank_sizes)
 	 */
-	memcpy(zhole_size, zone_size, sizeof(zhole_size));
+	memcpy(zhole_size, zone_size, sizeof(zhole_size));//计算空洞大小，默认整个zone都是空洞
 	for_each_memblock(memory, reg) {
 		unsigned long start = memblock_region_memory_base_pfn(reg);
 		unsigned long end = memblock_region_memory_end_pfn(reg);
 
-		if (start < max_low) {
+		if (start < max_low) {//从空洞中减去可用内存区域
 			unsigned long low_end = min(end, max_low);
 			zhole_size[0] -= low_end - start;
 		}
 #ifdef CONFIG_HIGHMEM
-		if (end > max_low) {
+		if (end > max_low) {//减去可用区域
 			unsigned long high_start = max(start, max_low);
 			zhole_size[ZONE_HIGHMEM] -= end - high_start;
 		}
@@ -180,11 +181,12 @@ static void __init zone_sizes_init(unsigned long min, unsigned long max_low,
 	 * Adjust the sizes according to any special requirements for
 	 * this machine type.
 	 */
-	if (arm_dma_zone_size)
+	if (arm_dma_zone_size)//调整dma zone
 		arm_adjust_dma_zone(zone_size, zhole_size,
 			arm_dma_zone_size >> PAGE_SHIFT);
 #endif
 
+	//根据起始位置和空洞大小，初始化0号内存区块。
 	free_area_init_node(0, zone_size, min, zhole_size);
 }
 
@@ -278,6 +280,9 @@ void __init arm_memblock_init(const struct machine_desc *mdesc)
 	memblock_dump_all();
 }
 
+/**
+ * boot内存初始化
+ */
 void __init bootmem_init(void)
 {
 	unsigned long min, max_low, max_high;
@@ -285,8 +290,10 @@ void __init bootmem_init(void)
 	memblock_allow_resize();
 	max_low = max_high = 0;
 
+	//计算所有内存块的pfn上下限。
 	find_limits(&min, &max_low, &max_high);
 
+	//内存测试，这个可以有
 	early_memtest((phys_addr_t)min << PAGE_SHIFT,
 		      (phys_addr_t)max_low << PAGE_SHIFT);
 
@@ -294,6 +301,9 @@ void __init bootmem_init(void)
 	 * Sparsemem tries to allocate bootmem in memory_present(),
 	 * so must be done after the fixed reservations
 	 */
+	/**
+	 * 如果支持分散内存，则记录下每块分散内存的起始、结束区域
+	 */
 	arm_memory_present();
 
 	/*
@@ -306,6 +316,9 @@ void __init bootmem_init(void)
 	 * the sparse mem_map arrays initialized by sparse_init()
 	 * for memmap_init_zone(), otherwise all PFNs are invalid.
 	 */
+	/**
+	 * 释放内存块
+	 */
 	zone_sizes_init(min, max_low, max_high);
 
 	/*
diff --git a/init/main.c b/init/main.c
index 9076b7cb..9c287104 100644
--- a/init/main.c
+++ b/init/main.c
@@ -363,10 +363,12 @@ static inline void smp_prepare_cpus(unsigned int maxcpus) { }
  */
 static void __init setup_command_line(char *command_line)
 {
+	//原始命令行
 	saved_command_line =
 		memblock_virt_alloc(strlen(boot_command_line) + 1, 0);
 	initcall_command_line =
 		memblock_virt_alloc(strlen(boot_command_line) + 1, 0);
+	//用于参数解析的命令行。
 	static_command_line = memblock_virt_alloc(strlen(command_line) + 1, 0);
 	strcpy(saved_command_line, boot_command_line);
 	strcpy(static_command_line, command_line);
@@ -558,16 +560,21 @@ asmlinkage __visible void __init start_kernel(void)
 	//处理CPU体系架构相关的事务。
 	setup_arch(&command_line);
 	mm_init_cpumask(&init_mm);
+	//保存命令行参数
 	setup_command_line(command_line);
 	setup_nr_cpu_ids();
+	//初始化每cpu数据
 	setup_per_cpu_areas();
+	//体系结构相关的SMP初始化，还是设置每cpu数据相关的东西
 	smp_prepare_boot_cpu();	/* arch-specific boot-cpu hooks */
 
 	build_all_zonelists(NULL, NULL);
 	page_alloc_init();
 
 	pr_notice("Kernel command line: %s\n", boot_command_line);
+	//解析内核参数，第一次解析
 	parse_early_param();
+	//第二次解析
 	after_dashes = parse_args("Booting kernel",
 				  static_command_line, __start___param,
 				  __stop___param - __start___param,
@@ -594,6 +601,7 @@ asmlinkage __visible void __init start_kernel(void)
 	 * timer interrupt). Full topology setup happens at smp_init()
 	 * time - but meanwhile we still have a functioning scheduler.
 	 */
+	//初始化调度器
 	sched_init();
 	/*
 	 * Disable preemption - early bootup scheduling is extremely
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index bcd214e4..516653cf 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -7304,6 +7304,9 @@ void __init sched_init(void)
 	int i, j;
 	unsigned long alloc_size = 0, ptr;
 
+	/**
+	 * 为进程的cgroup控制组分配内存
+	 */
 #ifdef CONFIG_FAIR_GROUP_SCHED
 	alloc_size += 2 * nr_cpu_ids * sizeof(void **);
 #endif
@@ -7337,6 +7340,7 @@ void __init sched_init(void)
 	}
 #endif /* CONFIG_CPUMASK_OFFSTACK */
 
+	//使用默认设置，对实时任务的CPU带宽进行设置。
 	init_rt_bandwidth(&def_rt_bandwidth,
 			global_rt_period(), global_rt_runtime());
 	init_dl_bandwidth(&def_dl_bandwidth,
diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h
index 6d2a119c..5699b05a 100644
--- a/kernel/sched/sched.h
+++ b/kernel/sched/sched.h
@@ -233,6 +233,10 @@ struct cfs_bandwidth {
 };
 
 /* task group related information */
+/**
+ * 任务组
+ * 用于支持cgroup的CPU资源控制
+ */
 struct task_group {
 	struct cgroup_subsys_state css;
 
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index 48aaf7b9..618c5b48 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -4617,6 +4617,10 @@ static void setup_zone_migrate_reserve(struct zone *zone)
  * up by free_all_bootmem() once the early boot process is
  * done. Non-atomic initialization, single-pass.
  */
+/**
+ * 将zone中的页框PG_reserved置位。表示该页不可用。
+ * 同时初始化页框中其他值。
+ */
 void __meminit memmap_init_zone(unsigned long size, int nid, unsigned long zone,
 		unsigned long start_pfn, enum memmap_context context)
 {
@@ -4908,8 +4912,10 @@ int __meminit init_currently_empty_zone(struct zone *zone,
 	ret = zone_wait_table_init(zone, size);
 	if (ret)
 		return ret;
+	//设置内存区中的zone个数，这个感觉有点奇怪
 	pgdat->nr_zones = zone_idx(zone) + 1;
 
+	//zone的起始pfn
 	zone->zone_start_pfn = zone_start_pfn;
 
 	mminit_dprintk(MMINIT_TRACE, "memmap_init",
@@ -4918,6 +4924,7 @@ int __meminit init_currently_empty_zone(struct zone *zone,
 			(unsigned long)zone_idx(zone),
 			zone_start_pfn, (zone_start_pfn + size));
 
+	//初始化free_area链表，并将空闲页面数量设置为0.
 	zone_init_free_lists(zone);
 
 	return 0;
@@ -5335,6 +5342,7 @@ static void __paginginit free_area_init_core(struct pglist_data *pgdat)
 	unsigned long zone_start_pfn = pgdat->node_start_pfn;
 	int ret;
 
+	//初始化节区的管理结构。
 	pgdat_resize_init(pgdat);
 #ifdef CONFIG_NUMA_BALANCING
 	spin_lock_init(&pgdat->numabalancing_migrate_lock);
@@ -5345,6 +5353,7 @@ static void __paginginit free_area_init_core(struct pglist_data *pgdat)
 	init_waitqueue_head(&pgdat->pfmemalloc_wait);
 	pgdat_page_ext_init(pgdat);
 
+	//遍历所有zone对其进行处理
 	for (j = 0; j < MAX_NR_ZONES; j++) {
 		struct zone *zone = pgdat->node_zones + j;
 		unsigned long size, realsize, freesize, memmap_pages;
@@ -5397,11 +5406,13 @@ static void __paginginit free_area_init_core(struct pglist_data *pgdat)
 						/ 100;
 		zone->min_slab_pages = (freesize * sysctl_min_slab_ratio) / 100;
 #endif
+		//初始化zone的数据。
 		zone->name = zone_names[j];
 		spin_lock_init(&zone->lock);
 		spin_lock_init(&zone->lru_lock);
 		zone_seqlock_init(zone);
 		zone->zone_pgdat = pgdat;
+		//初始化zone的每cpu缓存数据
 		zone_pcp_init(zone);
 
 		/* For bootup, initialized properly in watermark setup */
@@ -5413,9 +5424,11 @@ static void __paginginit free_area_init_core(struct pglist_data *pgdat)
 
 		set_pageblock_order();
 		setup_usemap(pgdat, zone, zone_start_pfn, size);
+		//初始化zone的free_area结构体。
 		ret = init_currently_empty_zone(zone, zone_start_pfn,
 						size, MEMMAP_EARLY);
 		BUG_ON(ret);
+		//设置所有页框的PG_reserved位。
 		memmap_init(size, nid, j, zone_start_pfn);
 		zone_start_pfn += size;
 	}
@@ -5474,6 +5487,7 @@ void __paginginit free_area_init_node(int nid, unsigned long *zones_size,
 	WARN_ON(pgdat->nr_zones || pgdat->classzone_idx);
 
 	reset_deferred_meminit(pgdat);
+	//设置内存区的节点号和起始pfn
 	pgdat->node_id = nid;
 	pgdat->node_start_pfn = node_start_pfn;
 #ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP
@@ -5482,9 +5496,13 @@ void __paginginit free_area_init_node(int nid, unsigned long *zones_size,
 		(u64)start_pfn << PAGE_SHIFT,
 		end_pfn ? ((u64)end_pfn << PAGE_SHIFT) - 1 : 0);
 #endif
+	/**
+	 * 初始化节点中每个zone的大小和空洞。
+	 */
 	calculate_node_totalpages(pgdat, start_pfn, end_pfn,
 				  zones_size, zholes_size);
 
+	//设置节点的node_mem_map
 	alloc_node_mem_map(pgdat);
 #ifdef CONFIG_FLAT_NODE_MEM_MAP
 	printk(KERN_DEBUG "free_area_init_node: node %d, pgdat %08lx, node_mem_map %08lx\n",
@@ -5492,6 +5510,7 @@ void __paginginit free_area_init_node(int nid, unsigned long *zones_size,
 		(unsigned long)pgdat->node_mem_map);
 #endif
 
+	//初始化zone，设置zone的free_area链表，标记所有页面不可用。
 	free_area_init_core(pgdat);
 }
 
-- 
2.25.1

