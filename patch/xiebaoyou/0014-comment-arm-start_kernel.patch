From 366f9557b3965424ef68c8589495b89b56c14692 Mon Sep 17 00:00:00 2001
From: "xie.baoyou" <scxby@163.com>
Date: Sat, 14 Nov 2015 14:50:57 +0800
Subject: [PATCH] =?UTF-8?q?[comment-arm]=20start=5Fkernel=E7=AC=AC?=
 =?UTF-8?q?=E4=BA=94=E9=83=A8=E5=88=86?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 include/linux/mmzone.h | 31 ++++++++++++++++
 init/main.c            |  8 +++++
 mm/page_alloc.c        | 80 +++++++++++++++++++++++++++++++++---------
 3 files changed, 103 insertions(+), 16 deletions(-)

diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h
index d9434773..675f7350 100644
--- a/include/linux/mmzone.h
+++ b/include/linux/mmzone.h
@@ -332,6 +332,7 @@ struct zone {
 	/* Read-mostly fields */
 
 	/* zone watermarks, access with *_wmark_pages(zone) macros */
+	//各种级别的水线需要保留的内存页面数量
 	unsigned long watermark[NR_WMARK];
 
 	/*
@@ -423,6 +424,7 @@ struct zone {
 	 * adjust_managed_page_count() should be used instead of directly
 	 * touching zone->managed_pages and totalram_pages.
 	 */
+	//该zone管理的页面数量
 	unsigned long		managed_pages;
 	unsigned long		spanned_pages;
 	unsigned long		present_pages;
@@ -650,9 +652,15 @@ static inline bool zone_is_empty(struct zone *zone)
  */
 
 
+/**
+ * 描述内存节点的备用zone列表的描述符，性能优化用
+ */
 struct zonelist_cache {
+	//zone所属的节点id
 	unsigned short z_to_n[MAX_ZONES_PER_ZONELIST];		/* zone->nid */
+	//相应的zone是否为full
 	DECLARE_BITMAP(fullzones, MAX_ZONES_PER_ZONELIST);	/* zone full? */
+	//最后检查的时间
 	unsigned long last_full_zap;		/* when last zap'd (jiffies) */
 };
 #else
@@ -664,8 +672,13 @@ struct zonelist_cache;
  * This struct contains information about a zone in a zonelist. It is stored
  * here to avoid dereferences into large structures and lookups of tables
  */
+/**
+ * 对zone的引用
+ */
 struct zoneref {
+	//实际引用的zone指针
 	struct zone *zone;	/* Pointer to actual zone */
+	//在引用数组中的索引
 	int zone_idx;		/* zone_idx(zoneref->zone) */
 };
 
@@ -686,10 +699,17 @@ struct zoneref {
  * zonelist_zone_idx()	- Return the index of the zone for an entry
  * zonelist_node_idx()	- Return the index of the node for an entry
  */
+/**
+ * 用于内存分配的zone列表
+ */
 struct zonelist {
 	struct zonelist_cache *zlcache_ptr;		     // NULL or &zlcache
+	/**
+	 * 最大节点数*每个节点的zone数量，对所有zone进行引用。
+	 */
 	struct zoneref _zonerefs[MAX_ZONES_PER_ZONELIST + 1];
 #ifdef CONFIG_NUMA
+	//用于优化，通过位图指示相应的zone是否有内存可用
 	struct zonelist_cache zlcache;			     // optional ...
 #endif
 };
@@ -711,8 +731,19 @@ extern struct page *mem_map;
  * per-zone basis.
  */
 struct bootmem_data;
+/**
+ * 内存区域，在非连续内存模型中，代表一块内存bank
+ * 在NUMA系统中，一般表示一个NUMA节点。
+ */
 typedef struct pglist_data {
 	struct zone node_zones[MAX_NR_ZONES];
+	/**
+	 * 元素0:
+	 *     当前节点中，每个zone的备份列表。
+	 *     当前节点的zone中无可用内存时，会向这些备用节点进行分配。
+	 * 元素1:
+	 *     当前节点中所有zone列表
+	 */
 	struct zonelist node_zonelists[MAX_ZONELISTS];
 	int nr_zones;
 #ifdef CONFIG_FLAT_NODE_MEM_MAP	/* means !SPARSEMEM */
diff --git a/init/main.c b/init/main.c
index 9c287104..2492d22a 100644
--- a/init/main.c
+++ b/init/main.c
@@ -568,7 +568,9 @@ asmlinkage __visible void __init start_kernel(void)
 	//体系结构相关的SMP初始化，还是设置每cpu数据相关的东西
 	smp_prepare_boot_cpu();	/* arch-specific boot-cpu hooks */
 
+	//继续初始化伙伴系统中的pglist_data，重点是初始化它的node_zonelist成员
 	build_all_zonelists(NULL, NULL);
+	//为CPU热插拨注册内存通知链
 	page_alloc_init();
 
 	pr_notice("Kernel command line: %s\n", boot_command_line);
@@ -590,9 +592,12 @@ asmlinkage __visible void __init start_kernel(void)
 	 * kmem_cache_init()
 	 */
 	setup_log_buf(0);
+	//进程pid管理用到的数据结构初始化。
 	pidhash_init();
 	vfs_caches_init_early();
+	//对异常表进行排序，以减少异常修复入口的查找时间
 	sort_main_extable();
+	//do nothing
 	trap_init();
 	mm_init();
 
@@ -612,6 +617,7 @@ asmlinkage __visible void __init start_kernel(void)
 		 "Interrupts were enabled *very* early, fixing it\n"))
 		local_irq_disable();
 	idr_init_cache();
+	//初始化cpu相关的rcu数据结构。注册rcu回调。
 	rcu_init();
 
 	/* trace_printk() and trace points may be used after this */
@@ -620,7 +626,9 @@ asmlinkage __visible void __init start_kernel(void)
 	context_tracking_init();
 	radix_tree_init();
 	/* init some links before init_ISA_irqs() */
+	//中断亲和性相关的初始化。
 	early_irq_init();
+	//中断初始化，注册bad_irq_desc
 	init_IRQ();
 	/**
 	 * 初始化时钟
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index 618c5b48..d971b983 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -3590,6 +3590,7 @@ EXPORT_SYMBOL_GPL(nr_free_buffer_pages);
  * nr_free_pagecache_pages() counts the number of pages which are beyond the
  * high watermark within all zones.
  */
+//在高水线上面的空页数
 unsigned long nr_free_pagecache_pages(void)
 {
 	return nr_free_zone_pages(gfp_zone(GFP_HIGHUSER_MOVABLE));
@@ -3868,16 +3869,20 @@ static void zoneref_set_zone(struct zone *zone, struct zoneref *zoneref)
  *
  * Add all populated zones of a node to the zonelist.
  */
+//将节点的zone添加到其他节点的备用列表中
 static int build_zonelists_node(pg_data_t *pgdat, struct zonelist *zonelist,
 				int nr_zones)
 {
 	struct zone *zone;
+	//从最后一个zone开始，当然要优先保护低地址的dma，normal区了。
 	enum zone_type zone_type = MAX_NR_ZONES;
 
 	do {
 		zone_type--;
+		//待加到备用列表中的zone
 		zone = pgdat->node_zones + zone_type;
-		if (populated_zone(zone)) {
+		if (populated_zone(zone)) {//这个zone上有内存
+			//加到备用列表中
 			zoneref_set_zone(zone,
 				&zonelist->_zonerefs[nr_zones++]);
 			check_highest_zone(zone_type);
@@ -4025,39 +4030,41 @@ static int find_next_best_node(int node, nodemask_t *used_node_mask)
 	const struct cpumask *tmp = cpumask_of_node(0);
 
 	/* Use the local node if we haven't already */
+	//当然优先从当前节点开始查找了。
 	if (!node_isset(node, *used_node_mask)) {
 		node_set(node, *used_node_mask);
 		return node;
 	}
 
+	//遍历所有节点
 	for_each_node_state(n, N_MEMORY) {
 
 		/* Don't want a node to appear more than once */
-		if (node_isset(n, *used_node_mask))
+		if (node_isset(n, *used_node_mask))//已经在备用列表中了，下一个
 			continue;
 
 		/* Use the distance array to find the distance */
-		val = node_distance(node, n);
+		val = node_distance(node, n);//计算节点之间的距离
 
 		/* Penalize nodes under us ("prefer the next node") */
-		val += (n < node);
+		val += (n < node);//如果是前面的节点，加一点距离，优先使用后面的节点
 
 		/* Give preference to headless and unused nodes */
 		tmp = cpumask_of_node(n);
-		if (!cpumask_empty(tmp))
+		if (!cpumask_empty(tmp))//没有设置CPU亲和性的?
 			val += PENALTY_FOR_NODE_WITH_CPUS;
 
 		/* Slight preference for less loaded node */
-		val *= (MAX_NODE_LOAD*MAX_NUMNODES);
+		val *= (MAX_NODE_LOAD*MAX_NUMNODES);//考虑该节点的负载
 		val += node_load[n];
 
-		if (val < min_val) {
+		if (val < min_val) {//找值最小的，即最优的节点
 			min_val = val;
 			best_node = n;
 		}
 	}
 
-	if (best_node >= 0)
+	if (best_node >= 0)//存在可用节点
 		node_set(best_node, *used_node_mask);
 
 	return best_node;
@@ -4069,15 +4076,20 @@ static int find_next_best_node(int node, nodemask_t *used_node_mask)
  * This results in maximum locality--normal zone overflows into local
  * DMA zone, if any--but risks exhausting DMA zone.
  */
+//按内存节点顺序排列zone备用列表
 static void build_zonelists_in_node_order(pg_data_t *pgdat, int node)
 {
 	int j;
 	struct zonelist *zonelist;
 
+	//备用zone列表指针
 	zonelist = &pgdat->node_zonelists[0];
+	//找到已经在列表中的zone数量，j是下一个可用索引
 	for (j = 0; zonelist->_zonerefs[j].zone != NULL; j++)
 		;
+	//将备用节点中的zone保存到最后一个可用位置
 	j = build_zonelists_node(NODE_DATA(node), zonelist, j);
+	//将后面的备用列表置为空。
 	zonelist->_zonerefs[j].zone = NULL;
 	zonelist->_zonerefs[j].zone_idx = 0;
 }
@@ -4090,7 +4102,9 @@ static void build_thisnode_zonelists(pg_data_t *pgdat)
 	int j;
 	struct zonelist *zonelist;
 
+	//本节点自己的zone列表
 	zonelist = &pgdat->node_zonelists[1];
+	//构建zone列表，当指定GFP_THISNODE时，使用本节点的zone列表进行分配。
 	j = build_zonelists_node(pgdat, zonelist, 0);
 	zonelist->_zonerefs[j].zone = NULL;
 	zonelist->_zonerefs[j].zone_idx = 0;
@@ -4104,6 +4118,9 @@ static void build_thisnode_zonelists(pg_data_t *pgdat)
  */
 static int node_order[MAX_NUMNODES];
 
+/**
+ * 以zone类型排列节点的备用列表
+ */
 static void build_zonelists_in_zone_order(pg_data_t *pgdat, int nr_nodes)
 {
 	int pos, j, node;
@@ -4113,17 +4130,20 @@ static void build_zonelists_in_zone_order(pg_data_t *pgdat, int nr_nodes)
 
 	zonelist = &pgdat->node_zonelists[0];
 	pos = 0;
+	//从高端zone向低端zone遍历。
 	for (zone_type = MAX_NR_ZONES - 1; zone_type >= 0; zone_type--) {
-		for (j = 0; j < nr_nodes; j++) {
-			node = node_order[j];
+		for (j = 0; j < nr_nodes; j++) {//处理所有备用节点
+			node = node_order[j];//前面已经按距离、负载等因素将节点排序了。
 			z = &NODE_DATA(node)->node_zones[zone_type];
-			if (populated_zone(z)) {
+			if (populated_zone(z)) {//这个zone上有内存
+				//记录到备用列表中
 				zoneref_set_zone(z,
 					&zonelist->_zonerefs[pos++]);
 				check_highest_zone(zone_type);
 			}
 		}
 	}
+	//将最后一个备用索引置空。
 	zonelist->_zonerefs[pos].zone = NULL;
 	zonelist->_zonerefs[pos].zone_idx = 0;
 }
@@ -4155,9 +4175,13 @@ static int default_zonelist_order(void)
 
 static void set_zonelist_order(void)
 {
-	if (user_zonelist_order == ZONELIST_ORDER_DEFAULT)
+	if (user_zonelist_order == ZONELIST_ORDER_DEFAULT)//默认排列方式
+		/**
+		 * 在64位机器上，使用DMA的时间比较少，因此可以按节点排列而不考虑DMA OOM，这样可以使程序运行得快一点。
+		 * 32位机器上，则默认使用zone排列方式。
+		 */
 		current_zonelist_order = default_zonelist_order();
-	else
+	else//使用用户指定的排列方式
 		current_zonelist_order = user_zonelist_order;
 }
 
@@ -4171,6 +4195,7 @@ static void build_zonelists(pg_data_t *pgdat)
 	int order = current_zonelist_order;
 
 	/* initialize zonelists */
+	//将节点的两个zonelist初始化为空。
 	for (i = 0; i < MAX_ZONELISTS; i++) {
 		zonelist = pgdat->node_zonelists + i;
 		zonelist->_zonerefs[0].zone = NULL;
@@ -4186,29 +4211,36 @@ static void build_zonelists(pg_data_t *pgdat)
 	memset(node_order, 0, sizeof(node_order));
 	j = 0;
 
+	//查找备用节点
 	while ((node = find_next_best_node(local_node, &used_mask)) >= 0) {
 		/*
 		 * We don't want to pressure a particular node.
 		 * So adding penalty to the first node in same
 		 * distance group to make it round-robin.
 		 */
+		/**
+		 * 如果当前选中的节点的距离与前一个节点相同，那么将当前节点负载加一点，这样下一次就不容易再选中该节点
+		 * 避免该节点被造成太大的压力。
+		 */
 		if (node_distance(local_node, node) !=
 		    node_distance(local_node, prev_node))
 			node_load[node] = load;
 
 		prev_node = node;
 		load--;
+		//以节点进行排列
 		if (order == ZONELIST_ORDER_NODE)
 			build_zonelists_in_node_order(pgdat, node);
-		else
+		else//以zone类型进行排列，在这里记下节点顺序
 			node_order[j++] = node;	/* remember order */
 	}
 
-	if (order == ZONELIST_ORDER_ZONE) {
+	if (order == ZONELIST_ORDER_ZONE) {//按zone类型为序进行排列
 		/* calculate node order -- i.e., DMA last! */
 		build_zonelists_in_zone_order(pgdat, j);
 	}
 
+	//构建本节点自己的zone列表(前面构建的是备用列表)
 	build_thisnode_zonelists(pgdat);
 }
 
@@ -4219,10 +4251,14 @@ static void build_zonelist_cache(pg_data_t *pgdat)
 	struct zonelist_cache *zlc;
 	struct zoneref *z;
 
+	//备用zone列表
 	zonelist = &pgdat->node_zonelists[0];
 	zonelist->zlcache_ptr = zlc = &zonelist->zlcache;
+	//将所有备用zone的full标志清空，表示其内存可用。
 	bitmap_zero(zlc->fullzones, MAX_ZONES_PER_ZONELIST);
+	//遍历所有备用缓存
 	for (z = zonelist->_zonerefs; z->zone; z++)
+		//设置zone对应的节点id
 		zlc->z_to_n[z - zonelist->_zonerefs] = zonelist_node_idx(z);
 }
 
@@ -4335,10 +4371,13 @@ static int __build_all_zonelists(void *data)
 		build_zonelist_cache(self);
 	}
 
+	//遍历所有节点
 	for_each_online_node(nid) {
 		pg_data_t *pgdat = NODE_DATA(nid);
 
+		//构建两个zonelist，一个是备用zone列表，一个是节点自己的zone列表。
 		build_zonelists(pgdat);
+		//构建备份列表的zone位图，如果相应的zone已经没有可用内存，则将位图置1.
 		build_zonelist_cache(pgdat);
 	}
 
@@ -4378,8 +4417,11 @@ static int __build_all_zonelists(void *data)
 static noinline void __init
 build_all_zonelists_init(void)
 {
+	//构建备份zone列表
 	__build_all_zonelists(NULL);
+	//balabala,输出备份列表信息
 	mminit_verify_zonelist();
+	//设置当前进程的mems_allowed位图，允许当前进程在所有节点中分配内存。
 	cpuset_init_current_mems_allowed();
 }
 
@@ -4394,9 +4436,10 @@ build_all_zonelists_init(void)
  */
 void __ref build_all_zonelists(pg_data_t *pgdat, struct zone *zone)
 {
+	//设置zone排列方式，是按节点之间的距离还是按zone类型。
 	set_zonelist_order();
 
-	if (system_state == SYSTEM_BOOTING) {
+	if (system_state == SYSTEM_BOOTING) {//启动阶段
 		build_all_zonelists_init();
 	} else {
 #ifdef CONFIG_MEMORY_HOTPLUG
@@ -4405,9 +4448,11 @@ void __ref build_all_zonelists(pg_data_t *pgdat, struct zone *zone)
 #endif
 		/* we have to stop all cpus to guarantee there is no user
 		   of zonelist */
+		//停止所有CPU，并让这些CPU在关中断的状态下调用__build_all_zonelists
 		stop_machine(__build_all_zonelists, pgdat, NULL);
 		/* cpuset refresh routine should be here */
 	}
+	//计算所有zone中，在高水线的情况下，可用的内存页面数量。
 	vm_total_pages = nr_free_pagecache_pages();
 	/*
 	 * Disable grouping by mobility if the number of pages in the
@@ -4416,6 +4461,9 @@ void __ref build_all_zonelists(pg_data_t *pgdat, struct zone *zone)
 	 * made on memory-hotadd so a system can start with mobility
 	 * disabled and enable it later
 	 */
+	/**
+	 * 如果可用内存较少，就不打开页面移动功能。
+	 */
 	if (vm_total_pages < (pageblock_nr_pages * MIGRATE_TYPES))
 		page_group_by_mobility_disabled = 1;
 	else
-- 
2.25.1

