From 997ad5e32853e0f38bd5e359defcc8f2d264f5b6 Mon Sep 17 00:00:00 2001
From: "xie.baoyou" <scxby@163.com>
Date: Sun, 15 Nov 2015 15:27:38 +0800
Subject: [PATCH] =?UTF-8?q?[comment-arm]=20start=5Fkernel=E7=AC=AC?=
 =?UTF-8?q?=E5=85=AB=E9=83=A8=E5=88=86?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 arch/arm/mm/init.c      | 18 +++++++++++++++---
 include/linux/bootmem.h |  3 +++
 init/main.c             |  1 +
 mm/bootmem.c            | 26 ++++++++++++++++++++++----
 mm/page_alloc.c         | 37 ++++++++++++++++++++++++++++++-------
 5 files changed, 71 insertions(+), 14 deletions(-)

diff --git a/arch/arm/mm/init.c b/arch/arm/mm/init.c
index db241284..5050d6b9 100644
--- a/arch/arm/mm/init.c
+++ b/arch/arm/mm/init.c
@@ -351,6 +351,7 @@ free_memmap(unsigned long start_pfn, unsigned long end_pfn)
 	/*
 	 * Convert start_pfn/end_pfn to a struct page pointer.
 	 */
+	//要释放的内存页帧描述符地址。
 	start_pg = pfn_to_page(start_pfn - 1) + 1;
 	end_pg = pfn_to_page(end_pfn - 1) + 1;
 
@@ -358,6 +359,7 @@ free_memmap(unsigned long start_pfn, unsigned long end_pfn)
 	 * Convert to physical addresses, and
 	 * round start upwards and end downwards.
 	 */
+	//将页帧地址对齐页边界，因为此时只能按页释放内存
 	pg = PAGE_ALIGN(__pa(start_pg));
 	pgend = __pa(end_pg) & PAGE_MASK;
 
@@ -365,13 +367,17 @@ free_memmap(unsigned long start_pfn, unsigned long end_pfn)
 	 * If there are free pages between these,
 	 * free the section of the memmap array.
 	 */
-	if (pg < pgend)
+	if (pg < pgend)//按页释放memmap对应的内存。
 		memblock_free_early(pg, pgend - pg);
 }
 
 /*
  * The mem_map array can get very big.  Free the unused area of the memory map.
  */
+/**
+ * memmap数组是一个连续的数组，记录内存状态。
+ * 本函数将不内存空洞对应的memmap内存释放。积少成多也是不少的内存空间。
+ */
 static void __init free_unused_memmap(void)
 {
 	unsigned long start, prev_end = 0;
@@ -381,7 +387,8 @@ static void __init free_unused_memmap(void)
 	 * This relies on each bank being in address order.
 	 * The banks are sorted previously in bootmem_init().
 	 */
-	for_each_memblock(memory, reg) {
+	for_each_memblock(memory, reg) {//遍历内存块
+		//找到该内存块的起始页帧号
 		start = memblock_region_memory_base_pfn(reg);
 
 #ifdef CONFIG_SPARSEMEM
@@ -403,7 +410,7 @@ static void __init free_unused_memmap(void)
 		 * If we had a previous bank, and there is a space
 		 * between the current bank and the previous, free it.
 		 */
-		if (prev_end && prev_end < start)
+		if (prev_end && prev_end < start)//与上一个内存块不连续，说明有空洞，释放memmap对应的内存。
 			free_memmap(prev_end, start);
 
 		/*
@@ -483,6 +490,9 @@ static void __init free_highpages(void)
  * memory is free.  This is done after various parts of the system have
  * claimed their memory after the kernel image.
  */
+/**
+ * 切换到伙伴系统了。
+ */
 void __init mem_init(void)
 {
 #ifdef CONFIG_HAVE_TCM
@@ -494,7 +504,9 @@ void __init mem_init(void)
 	set_max_mapnr(pfn_to_page(max_pfn) - mem_map);
 
 	/* this will put all unused low memory onto the freelists */
+	//释放内存空洞对应的memmap数组空间。
 	free_unused_memmap();
+	//将未用bootmem释放给伙伴系统。
 	free_all_bootmem();
 
 #ifdef CONFIG_SA1111
diff --git a/include/linux/bootmem.h b/include/linux/bootmem.h
index bd4d505e..6a05789a 100644
--- a/include/linux/bootmem.h
+++ b/include/linux/bootmem.h
@@ -26,8 +26,11 @@ extern unsigned long max_pfn;
  * memory pages (including holes) on the node.
  */
 typedef struct bootmem_data {
+	//内存块的最小页帧号
 	unsigned long node_min_pfn;
+	//内存块的低端页帧号，高于此页帧的都被分配了。
 	unsigned long node_low_pfn;
+	//内存块的页面映射位图
 	void *node_bootmem_map;
 	unsigned long last_end_off;
 	unsigned long hint_idx;
diff --git a/init/main.c b/init/main.c
index 822744eb..286bec1e 100644
--- a/init/main.c
+++ b/init/main.c
@@ -499,6 +499,7 @@ static void __init mm_init(void)
 	 * bigger than MAX_ORDER unless SPARSEMEM.
 	 */
 	page_ext_init_flatmem();
+	//将boot内存管理转换为伙伴内存管理
 	mem_init();
 	kmem_cache_init();
 	percpu_init_late();
diff --git a/mm/bootmem.c b/mm/bootmem.c
index 266147bf..ae96ea47 100644
--- a/mm/bootmem.c
+++ b/mm/bootmem.c
@@ -169,6 +169,9 @@ void __init free_bootmem_late(unsigned long physaddr, unsigned long size)
 	}
 }
 
+/**
+ * 释放某个内存块中的内存到伙伴系统中
+ */
 static unsigned long __init free_all_bootmem_core(bootmem_data_t *bdata)
 {
 	struct page *page;
@@ -177,6 +180,7 @@ static unsigned long __init free_all_bootmem_core(bootmem_data_t *bdata)
 	if (!bdata->node_bootmem_map)
 		return 0;
 
+	//内存块的映射位图，起始结束页帧号
 	map = bdata->node_bootmem_map;
 	start = bdata->node_min_pfn;
 	end = bdata->node_low_pfn;
@@ -184,10 +188,11 @@ static unsigned long __init free_all_bootmem_core(bootmem_data_t *bdata)
 	bdebug("nid=%td start=%lx end=%lx\n",
 		bdata - bootmem_node_data, start, end);
 
-	while (start < end) {
+	while (start < end) {//依次释放每一页
 		unsigned long idx, vec;
 		unsigned shift;
 
+		//该页在位图中的值
 		idx = start - bdata->node_min_pfn;
 		shift = idx & (BITS_PER_LONG - 1);
 		/*
@@ -207,17 +212,18 @@ static unsigned long __init free_all_bootmem_core(bootmem_data_t *bdata)
 		 * BITS_PER_LONG block of pages in front of us, free
 		 * it in one go.
 		 */
-		if (IS_ALIGNED(start, BITS_PER_LONG) && vec == ~0UL) {
+		if (IS_ALIGNED(start, BITS_PER_LONG) && vec == ~0UL) {//连续多个页面都可用
 			int order = ilog2(BITS_PER_LONG);
 
+			//一次性释放多个内存给伙伴系统
 			__free_pages_bootmem(pfn_to_page(start), start, order);
 			count += BITS_PER_LONG;
 			start += BITS_PER_LONG;
-		} else {
+		} else {//只能单个页面释放回去了
 			cur = start;
 
 			start = ALIGN(start + 1, BITS_PER_LONG);
-			while (vec && cur != start) {
+			while (vec && cur != start) {//一个一个的释放回去。
 				if (vec & 1) {
 					page = pfn_to_page(cur);
 					__free_pages_bootmem(page, cur, 0);
@@ -232,8 +238,10 @@ static unsigned long __init free_all_bootmem_core(bootmem_data_t *bdata)
 	cur = bdata->node_min_pfn;
 	page = virt_to_page(bdata->node_bootmem_map);
 	pages = bdata->node_low_pfn - bdata->node_min_pfn;
+	//计算memmap数组占用了多少页
 	pages = bootmem_bootmap_pages(pages);
 	count += pages;
+	//将memmap数组一页一页的释放给伙伴系统。
 	while (pages--)
 		__free_pages_bootmem(page++, cur++, 0);
 	bdata->node_bootmem_map = NULL;
@@ -271,16 +279,26 @@ void __init reset_all_zones_managed_pages(void)
  *
  * Returns the number of pages actually released.
  */
+/**
+ * 将bootmem中的空闲页释放到伙伴系统中。
+ */
 unsigned long __init free_all_bootmem(void)
 {
 	unsigned long total_pages = 0;
 	bootmem_data_t *bdata;
 
+	/**
+	 * 设置所有内存块的所有zone，将其管理的页面重置为0
+	 * 为什么重置呢???
+	 */
 	reset_all_zones_managed_pages();
 
+	//遍历所有内存块
 	list_for_each_entry(bdata, &bdata_list, list)
+		//将不需要的内存返还给伙伴系统、
 		total_pages += free_all_bootmem_core(bdata);
 
+	//记录下所有可用的内存页面数量。
 	totalram_pages += total_pages;
 
 	return total_pages;
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index 7681e466..e22ae15c 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -965,6 +965,7 @@ static bool free_pages_prepare(struct page *page, unsigned int order)
 	return true;
 }
 
+//释放多个页面到内存中
 static void __free_pages_ok(struct page *page, unsigned int order)
 {
 	unsigned long flags;
@@ -981,6 +982,7 @@ static void __free_pages_ok(struct page *page, unsigned int order)
 	local_irq_restore(flags);
 }
 
+//将bootmem页面释放给伙伴系统。
 static void __init __free_pages_boot_core(struct page *page,
 					unsigned long pfn, unsigned int order)
 {
@@ -988,17 +990,28 @@ static void __init __free_pages_boot_core(struct page *page,
 	struct page *p = page;
 	unsigned int loop;
 
+	//数据预取
 	prefetchw(p);
+	//遍历所有页面
 	for (loop = 0; loop < (nr_pages - 1); loop++, p++) {
 		prefetchw(p + 1);
+		//清除其reserved标志，表示页面可用可交换
 		__ClearPageReserved(p);
-		set_page_count(p, 0);
+		set_page_count(p, 0);//将页面引用计数设置为0
 	}
+	/**
+	 * 前面的循环少了一页，这里将最后一页标志置位
+	 * 仅仅因为预取的关系，把程序复杂了，感觉不值。
+	 */
 	__ClearPageReserved(p);
 	set_page_count(p, 0);
 
+	//增加zone的页面计数
 	page_zone(page)->managed_pages += nr_pages;
+	//这里将第一个页面引用计数设置为1!!!!!
 	set_page_refcounted(page);
+	//将页面添加到zone的链表中。
+	//释放后，其引用计数又成0了，这里注意体会一下。
 	__free_pages(page, order);
 }
 
@@ -1917,8 +1930,12 @@ void mark_free_pages(struct zone *zone)
  * Free a 0-order page
  * cold == true ? free a cold page : free a hot page
  */
+/**
+ * 将单个页面释放给伙伴系统
+ */
 void free_hot_cold_page(struct page *page, bool cold)
 {
+	//页面所属的zone
 	struct zone *zone = page_zone(page);
 	struct per_cpu_pages *pcp;
 	unsigned long flags;
@@ -1948,12 +1965,15 @@ void free_hot_cold_page(struct page *page, bool cold)
 		migratetype = MIGRATE_MOVABLE;
 	}
 
+	//当前CPU的缓存
 	pcp = &this_cpu_ptr(zone->pageset)->pcp;
-	if (!cold)
+	if (!cold)//加到缓存的前面，保持其热度。
 		list_add(&page->lru, &pcp->lists[migratetype]);
-	else
+	else//否则加到后面
 		list_add_tail(&page->lru, &pcp->lists[migratetype]);
+	//缓存计数
 	pcp->count++;
+	//缓存中页面过多，还到链表中去.
 	if (pcp->count >= pcp->high) {
 		unsigned long batch = READ_ONCE(pcp->batch);
 		free_pcppages_bulk(zone, batch, pcp);
@@ -3298,12 +3318,15 @@ unsigned long get_zeroed_page(gfp_t gfp_mask)
 }
 EXPORT_SYMBOL(get_zeroed_page);
 
+/**
+ * 释放多个页面到伙伴系统
+ */
 void __free_pages(struct page *page, unsigned int order)
 {
-	if (put_page_testzero(page)) {
-		if (order == 0)
-			free_hot_cold_page(page, false);
-		else
+	if (put_page_testzero(page)) {//递减引用计数，如果为0表示没有人引用了。
+		if (order == 0)//如果是单个页
+			free_hot_cold_page(page, false);//将它放到hot池中，性能优化考虑。
+		else//否则直接放回链表中
 			__free_pages_ok(page, order);
 	}
 }
-- 
2.25.1

