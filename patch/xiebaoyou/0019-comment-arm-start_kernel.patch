From ae7f7b0cf35db0bb5a2ceeab9d4cd2da7275140b Mon Sep 17 00:00:00 2001
From: "xie.baoyou" <scxby@163.com>
Date: Mon, 16 Nov 2015 16:18:38 +0800
Subject: [PATCH] =?UTF-8?q?[comment-arm]=20start=5Fkernel=E7=AC=AC?=
 =?UTF-8?q?=E5=8D=81=E9=83=A8=E5=88=86?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 include/linux/mm.h             |  2 ++
 include/linux/mmzone.h         |  8 ++++++++
 include/linux/slab.h           |  1 +
 include/uapi/linux/mempolicy.h |  4 ++++
 init/calibrate.c               | 13 +++++++++----
 init/main.c                    | 17 +++++++++++++++++
 kernel/cred.c                  |  4 ++++
 kernel/pid.c                   |  4 ++++
 lib/idr.c                      |  4 ++++
 mm/page_alloc.c                |  5 ++++-
 mm/rmap.c                      |  4 ++++
 11 files changed, 61 insertions(+), 5 deletions(-)

diff --git a/include/linux/mm.h b/include/linux/mm.h
index 80001de0..5345a97d 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -1600,7 +1600,9 @@ static inline void pte_lock_deinit(struct page *page) {}
 
 static inline void pgtable_init(void)
 {
+	//创建slab管理器，用于页表锁。
 	ptlock_cache_init();
+	//do nothing
 	pgtable_cache_init();
 }
 
diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h
index 675f7350..dcdce6c0 100644
--- a/include/linux/mmzone.h
+++ b/include/linux/mmzone.h
@@ -250,14 +250,21 @@ enum zone_watermarks {
 #define high_wmark_pages(z) (z->watermark[WMARK_HIGH])
 
 struct per_cpu_pages {
+	//当前数量
 	int count;		/* number of pages in the list */
+	//高水线，高于此数将内存还给伙伴系统
 	int high;		/* high watermark, emptying needed */
+	//一次性添加和删除的页面数量
 	int batch;		/* chunk size for buddy add/remove */
 
 	/* Lists of pages, one per migrate type stored on the pcp-lists */
+	//缓存的页链表
 	struct list_head lists[MIGRATE_PCPTYPES];
 };
 
+/**
+ * 每个zone上面的pageset缓存页。
+ */
 struct per_cpu_pageset {
 	struct per_cpu_pages pcp;
 #ifdef CONFIG_NUMA
@@ -356,6 +363,7 @@ struct zone {
 	unsigned int inactive_ratio;
 
 	struct pglist_data	*zone_pgdat;
+	//每CPU的页面缓存。
 	struct per_cpu_pageset __percpu *pageset;
 
 	/*
diff --git a/include/linux/slab.h b/include/linux/slab.h
index 7e37d448..fa2189fc 100644
--- a/include/linux/slab.h
+++ b/include/linux/slab.h
@@ -26,6 +26,7 @@
 #define SLAB_HWCACHE_ALIGN	0x00002000UL	/* Align objs on cache lines */
 #define SLAB_CACHE_DMA		0x00004000UL	/* Use GFP_DMA memory */
 #define SLAB_STORE_USER		0x00010000UL	/* DEBUG: Store the last owner for bug hunting */
+//如果失败就panic
 #define SLAB_PANIC		0x00040000UL	/* Panic if kmem_cache_create() fails */
 /*
  * SLAB_DESTROY_BY_RCU - **WARNING** READ THIS!
diff --git a/include/uapi/linux/mempolicy.h b/include/uapi/linux/mempolicy.h
index 9cd8b21d..e2098a93 100644
--- a/include/uapi/linux/mempolicy.h
+++ b/include/uapi/linux/mempolicy.h
@@ -16,9 +16,13 @@
 
 /* Policies */
 enum {
+	//内部使用
 	MPOL_DEFAULT,
+	//内存分配在策略给定的一个节点中完成，失败后在其他节点中分配
 	MPOL_PREFERRED,
+	//只在给定的节点中进行分配。在最近的节点中分配，失败后不在其他节点中分配。
 	MPOL_BIND,
+	//将多个节点组成一个节点后进行内存分配。失败后在其他节点中分配。
 	MPOL_INTERLEAVE,
 	MPOL_LOCAL,
 	MPOL_MAX,	/* always last member of enum */
diff --git a/init/calibrate.c b/init/calibrate.c
index ce635dcc..2d4da5e0 100644
--- a/init/calibrate.c
+++ b/init/calibrate.c
@@ -183,6 +183,7 @@ static unsigned long calibrate_delay_direct(void)
  */
 #define LPS_PREC 8
 
+//测算BogoMIPS
 static unsigned long calibrate_delay_converge(void)
 {
 	/* First stage - slowly accelerate to find initial bounds */
@@ -193,10 +194,10 @@ static unsigned long calibrate_delay_converge(void)
 
 	/* wait for "start of" clock tick */
 	ticks = jiffies;
-	while (ticks == jiffies)
+	while (ticks == jiffies)//等待jiffies发生变化
 		; /* nothing */
 	/* Go .. */
-	ticks = jiffies;
+	ticks = jiffies;//新的jiffies开始了
 	do {
 		if (++trial_in_band == (1<<band)) {
 			++band;
@@ -204,7 +205,7 @@ static unsigned long calibrate_delay_converge(void)
 		}
 		__delay(lpj * band);
 		trials += band;
-	} while (ticks == jiffies);
+	} while (ticks == jiffies);//循环一直等待jiffies发生变化。
 	/*
 	 * We overshot, so retreat to a clear underestimate. Then estimate
 	 * the largest likely undershoot. This defines our chop bounds.
@@ -271,13 +272,17 @@ void __attribute__((weak)) calibration_delay_done(void)
 {
 }
 
+/**
+ * 测算BogoMIPS
+ */
 void calibrate_delay(void)
 {
 	unsigned long lpj;
 	static bool printed;
 	int this_cpu = smp_processor_id();
 
-	if (per_cpu(cpu_loops_per_jiffy, this_cpu)) {
+	if (per_cpu(cpu_loops_per_jiffy, this_cpu)) {//当前CPU已经计算了值
+		//直接打印出来
 		lpj = per_cpu(cpu_loops_per_jiffy, this_cpu);
 		if (!printed)
 			pr_info("Calibrating delay loop (skipped) "
diff --git a/init/main.c b/init/main.c
index 94615d68..b0f4048c 100644
--- a/init/main.c
+++ b/init/main.c
@@ -506,6 +506,7 @@ static void __init mm_init(void)
 	 */
 	kmem_cache_init();
 	percpu_init_late();
+	//页表相关的初始化，其实就是创建一个slab分配器，用于页表锁的分配。
 	pgtable_init();
 	//初始化vmalloc用到的数据结构
 	vmalloc_init();
@@ -631,6 +632,7 @@ asmlinkage __visible void __init start_kernel(void)
 	if (WARN(!irqs_disabled(),
 		 "Interrupts were enabled *very* early, fixing it\n"))
 		local_irq_disable();
+	//idr用于管理整数ID，为POSIX计时器相关系统所用，生成特定计时器对象的ID.
 	idr_init_cache();
 	//初始化cpu相关的rcu数据结构。注册rcu回调。
 	rcu_init();
@@ -705,15 +707,23 @@ asmlinkage __visible void __init start_kernel(void)
 	}
 #endif
 	page_ext_init();
+	//内核对象跟踪
 	debug_objects_mem_init();
+	//内存泄漏检测初始化
 	kmemleak_init();
+	//设置pageset，即每个zone上面的每cpu页面缓存
 	setup_per_cpu_pageset();
+	//将16M以上的内存节点指定为交叉节点，并设置当前进程的模式
 	numa_policy_init();
+	//延后的时钟初始化操作
 	if (late_time_init)
 		late_time_init();
 	sched_clock_init();
+	//测试BogoMIPS值，计算每个jiffy内消耗掉多少CPU周期。
 	calibrate_delay();
+	//快速执行pid分配，分配pid位图并生成slab缓存.
 	pidmap_init();
+	//为anon_vma生成slab分配器。
 	anon_vma_init();
 	acpi_early_init();
 #ifdef CONFIG_X86
@@ -724,12 +734,19 @@ asmlinkage __visible void __init start_kernel(void)
 	/* Should be run before the first non-init thread is created */
 	init_espfix_bsp();
 #endif
+	//do nothing
 	thread_info_cache_init();
+	//审计初始化，用于确定对象是否有执行某种操作的资格。
 	cred_init();
+	//初始化fork中使用的资源相关数据结构。
 	fork_init();
+	//用于生成进程管理所需要的slab管理器
 	proc_caches_init();
+	//初始化buffer,用于缓存从块设备中读取的块。为其构建slab缓存管理器。
 	buffer_init();
+	//密钥服务初始化。
 	key_init();
+	//安全子系统初始化。
 	security_init();
 	dbg_late_init();
 	vfs_caches_init();
diff --git a/kernel/cred.c b/kernel/cred.c
index 71179a09..4b98827a 100644
--- a/kernel/cred.c
+++ b/kernel/cred.c
@@ -566,9 +566,13 @@ EXPORT_SYMBOL(revert_creds);
 /*
  * initialise the credentials stuff
  */
+/**
+ * 审计子系统初始化
+ */
 void __init cred_init(void)
 {
 	/* allocate a slab in which we can store credentials */
+	//分配一个slab管理器而已。
 	cred_jar = kmem_cache_create("cred_jar", sizeof(struct cred),
 				     0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);
 }
diff --git a/kernel/pid.c b/kernel/pid.c
index 36afec8a..205b6d25 100644
--- a/kernel/pid.c
+++ b/kernel/pid.c
@@ -589,6 +589,10 @@ void __init pidhash_init(void)
 		INIT_HLIST_HEAD(&pid_hash[i]);
 }
 
+/**
+ * 初始化进程地址空间
+ * 这里初始化init_pid_ns地址空间。
+ */
 void __init pidmap_init(void)
 {
 	/* Veryify no one has done anything silly */
diff --git a/lib/idr.c b/lib/idr.c
index 5335c43a..88b0d819 100644
--- a/lib/idr.c
+++ b/lib/idr.c
@@ -822,6 +822,10 @@ void *idr_replace(struct idr *idp, void *ptr, int id)
 }
 EXPORT_SYMBOL(idr_replace);
 
+/**
+ * idr将整数与指针关联起来
+ * 这里构造它的slab管理器。
+ */
 void __init idr_init_cache(void)
 {
 	idr_layer_cache = kmem_cache_create("idr_layer_cache",
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index e22ae15c..4c86d5bc 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -4898,8 +4898,9 @@ static void __meminit zone_pageset_init(struct zone *zone, int cpu)
 static void __meminit setup_zone_pageset(struct zone *zone)
 {
 	int cpu;
+	//分配zone的pageset结构
 	zone->pageset = alloc_percpu(struct per_cpu_pageset);
-	for_each_possible_cpu(cpu)
+	for_each_possible_cpu(cpu)//初始化pageset的值。
 		zone_pageset_init(zone, cpu);
 }
 
@@ -4911,7 +4912,9 @@ void __init setup_per_cpu_pageset(void)
 {
 	struct zone *zone;
 
+	//遍历所有zone
 	for_each_populated_zone(zone)
+		//设置每个zone的每CPU缓存。
 		setup_zone_pageset(zone);
 }
 
diff --git a/mm/rmap.c b/mm/rmap.c
index f5b5c1f3..f5fef708 100644
--- a/mm/rmap.c
+++ b/mm/rmap.c
@@ -425,6 +425,10 @@ static void anon_vma_ctor(void *data)
 	anon_vma->rb_root = RB_ROOT;
 }
 
+/**
+ * 为anon_vma分配slab管理器。
+ * 用于反向映射，通过页框找到引用项，便于页面回收。
+ */
 void __init anon_vma_init(void)
 {
 	anon_vma_cachep = kmem_cache_create("anon_vma", sizeof(struct anon_vma),
-- 
2.25.1

