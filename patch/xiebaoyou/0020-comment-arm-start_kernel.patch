From 2e2a720490a736f95f302e062e6d16f25ae83591 Mon Sep 17 00:00:00 2001
From: "xie.baoyou" <scxby@163.com>
Date: Tue, 17 Nov 2015 11:12:45 +0800
Subject: [PATCH] =?UTF-8?q?[comment-arm]=20start=5Fkernel=E7=AC=AC?=
 =?UTF-8?q?=E5=8D=81=E4=B8=80=E9=83=A8=E5=88=86?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 fs/buffer.c                   | 12 ++++++++++++
 include/linux/key.h           |  3 +++
 include/linux/sched.h         |  1 +
 include/uapi/linux/resource.h |  3 +++
 kernel/fork.c                 | 15 +++++++++++++++
 security/keys/key.c           |  6 ++++++
 6 files changed, 40 insertions(+)

diff --git a/fs/buffer.c b/fs/buffer.c
index 82283abb..8d439f9c 100644
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@ -3316,6 +3316,9 @@ static struct kmem_cache *bh_cachep __read_mostly;
  * Once the number of bh's in the machine exceeds this level, we start
  * stripping them in writeback.
  */
+/**
+ * buffer_head的数量，根据normal区10%的页面计算出来。
+ */
 static unsigned long max_buffer_heads;
 
 int buffer_heads_over_limit;
@@ -3430,10 +3433,14 @@ int bh_submit_read(struct buffer_head *bh)
 }
 EXPORT_SYMBOL(bh_submit_read);
 
+/**
+ * 初始化与块设备buffer_head元数据相关的缓存
+ */
 void __init buffer_init(void)
 {
 	unsigned long nrpages;
 
+	//创建buffer_head内存分配控制器
 	bh_cachep = kmem_cache_create("buffer_head",
 			sizeof(struct buffer_head), 0,
 				(SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|
@@ -3443,7 +3450,12 @@ void __init buffer_init(void)
 	/*
 	 * Limit the bh occupancy to 10% of ZONE_NORMAL
 	 */
+	/**
+	 * buffer_head缓存元数据，因此内核需要经常访问。
+	 * 限制其使用的缓存为Normal区域的10%
+	 */
 	nrpages = (nr_free_buffer_pages() * 10) / 100;
 	max_buffer_heads = nrpages * (PAGE_SIZE / sizeof(struct buffer_head));
+	//注册CPU热插拨侦听事件
 	hotcpu_notifier(buffer_cpu_notify, 0);
 }
diff --git a/include/linux/key.h b/include/linux/key.h
index e1d4715f..1b1afcd0 100644
--- a/include/linux/key.h
+++ b/include/linux/key.h
@@ -129,8 +129,10 @@ static inline bool is_key_possessed(const key_ref_t key_ref)
  *   - disk encryption IDs
  *   - Kerberos TGTs and tickets
  */
+//密钥
 struct key {
 	atomic_t		usage;		/* number of references */
+	//序列号
 	key_serial_t		serial;		/* key serial number */
 	union {
 		struct list_head graveyard_link;
@@ -181,6 +183,7 @@ struct key {
 	union {
 		struct keyring_index_key index_key;
 		struct {
+			//类型
 			struct key_type	*type;		/* type of key */
 			char		*description;
 		};
diff --git a/include/linux/sched.h b/include/linux/sched.h
index b7b9501b..f586414d 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -749,6 +749,7 @@ struct signal_struct {
 	 * protect this instead of the siglock, because they really
 	 * have no need to disable irqs.
 	 */
+	//进程的资源限制
 	struct rlimit rlim[RLIM_NLIMITS];
 
 #ifdef CONFIG_BSD_PROCESS_ACCT
diff --git a/include/uapi/linux/resource.h b/include/uapi/linux/resource.h
index 36fb3b5f..5db64440 100644
--- a/include/uapi/linux/resource.h
+++ b/include/uapi/linux/resource.h
@@ -39,8 +39,11 @@ struct	rusage {
 	__kernel_long_t	ru_nivcsw;	/* involuntary " */
 };
 
+//资源限制描述符
 struct rlimit {
+	//当前生效的限制值，可由用户修改
 	__kernel_ulong_t	rlim_cur;
+	//最大限制值
 	__kernel_ulong_t	rlim_max;
 };
 
diff --git a/kernel/fork.c b/kernel/fork.c
index 2845623f..163bc818 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -292,6 +292,9 @@ static void set_max_threads(unsigned int max_threads_suggested)
 int arch_task_struct_size __read_mostly;
 #endif
 
+/**
+ * 初始化fork需要的系统资源。
+ */
 void __init fork_init(void)
 {
 #ifndef CONFIG_ARCH_TASK_STRUCT_ALLOCATOR
@@ -299,16 +302,20 @@ void __init fork_init(void)
 #define ARCH_MIN_TASKALIGN	L1_CACHE_BYTES
 #endif
 	/* create a slab on which task_structs can be allocated */
+	//task_struct分配控制器。
 	task_struct_cachep =
 		kmem_cache_create("task_struct", arch_task_struct_size,
 			ARCH_MIN_TASKALIGN, SLAB_PANIC | SLAB_NOTRACK, NULL);
 #endif
 
 	/* do the arch specific task caches init */
+	//arm未定义
 	arch_task_cache_init();
 
+	//根据内存页面数量及mutex限制，设置最大线程数量。
 	set_max_threads(MAX_THREADS);
 
+	//当前进程的线程数量限制，默认为总数量的一半
 	init_task.signal->rlim[RLIMIT_NPROC].rlim_cur = max_threads/2;
 	init_task.signal->rlim[RLIMIT_NPROC].rlim_max = max_threads/2;
 	init_task.signal->rlim[RLIMIT_SIGPENDING] =
@@ -1848,8 +1855,12 @@ static void sighand_ctor(void *data)
 	init_waitqueue_head(&sighand->signalfd_wqh);
 }
 
+/**
+ * 与进程资源相关的初始化
+ */
 void __init proc_caches_init(void)
 {
+	//进程信号处理需要的内存分配控制器
 	sighand_cachep = kmem_cache_create("sighand_cache",
 			sizeof(struct sighand_struct), 0,
 			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_DESTROY_BY_RCU|
@@ -1857,9 +1868,11 @@ void __init proc_caches_init(void)
 	signal_cachep = kmem_cache_create("signal_cache",
 			sizeof(struct signal_struct), 0,
 			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);
+	//文件句柄管理需要的内存分配控制器
 	files_cachep = kmem_cache_create("files_cache",
 			sizeof(struct files_struct), 0,
 			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);
+	//进程当前路径、根目录相关的内存分配控制器。
 	fs_cachep = kmem_cache_create("fs_cache",
 			sizeof(struct fs_struct), 0,
 			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);
@@ -1870,10 +1883,12 @@ void __init proc_caches_init(void)
 	 * maximum number of CPU's we can ever have.  The cpumask_allocation
 	 * is at the end of the structure, exactly for that reason.
 	 */
+	//mm_struct内存分配控制器
 	mm_cachep = kmem_cache_create("mm_struct",
 			sizeof(struct mm_struct), ARCH_MIN_MMSTRUCT_ALIGN,
 			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);
 	vm_area_cachep = KMEM_CACHE(vm_area_struct, SLAB_PANIC);
+	//初始化vm_committed_as，用于记录进程虚拟地址空间
 	mmap_init();
 	nsproxy_cache_init();
 }
diff --git a/security/keys/key.c b/security/keys/key.c
index aee2ec5a..2b7e2537 100644
--- a/security/keys/key.c
+++ b/security/keys/key.c
@@ -1118,19 +1118,25 @@ EXPORT_SYMBOL(unregister_key_type);
 /*
  * Initialise the key management state.
  */
+/**
+ * 初始化密钥
+ */
 void __init key_init(void)
 {
 	/* allocate a slab in which we can store keys */
+	//存储密钥的slab
 	key_jar = kmem_cache_create("key_jar", sizeof(struct key),
 			0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);
 
 	/* add the special key types */
+	//将几种密钥类型添加到全局链表中
 	list_add_tail(&key_type_keyring.link, &key_types_list);
 	list_add_tail(&key_type_dead.link, &key_types_list);
 	list_add_tail(&key_type_user.link, &key_types_list);
 	list_add_tail(&key_type_logon.link, &key_types_list);
 
 	/* record the root user tracking */
+	//将root用户的密钥管理结构加到红黑树中。
 	rb_link_node(&root_key_user.node,
 		     NULL,
 		     &key_user_tree.rb_node);
-- 
2.25.1

