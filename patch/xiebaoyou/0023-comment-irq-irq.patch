From 332f66f3a3b67aa45447361d1e3c749468fad866 Mon Sep 17 00:00:00 2001
From: "xie.baoyou" <scxby@163.com>
Date: Mon, 9 Oct 2017 16:18:33 +0800
Subject: [PATCH] =?UTF-8?q?[comment-irq]=20irq=E6=A1=86=E6=9E=B6=E7=AC=AC?=
 =?UTF-8?q?=E4=B8=80=E9=83=A8=E5=88=86?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 arch/arm/include/asm/irq.h |  4 ++
 drivers/irqchip/irq-gic.c  | 59 ++++++++++++++++++++++++++-
 drivers/of/irq.c           | 13 ++++++
 include/linux/interrupt.h  | 35 ++++++++++++++++
 include/linux/irq.h        | 12 ++++++
 include/linux/irqdesc.h    | 10 ++++-
 include/linux/irqdomain.h  | 52 ++++++++++++++++++++++++
 include/linux/of.h         |  6 +++
 kernel/irq/chip.c          | 40 +++++++++++++++++++
 kernel/irq/handle.c        |  4 ++
 kernel/irq/irqdesc.c       |  4 ++
 kernel/irq/irqdomain.c     | 56 ++++++++++++++++++++++++--
 kernel/irq/manage.c        | 81 ++++++++++++++++++++++++++++++++------
 kernel/irq/resend.c        | 20 ++++++++++
 kernel/irq/spurious.c      |  4 ++
 15 files changed, 381 insertions(+), 19 deletions(-)
 mode change 100644 => 100755 arch/arm/include/asm/irq.h
 mode change 100644 => 100755 drivers/irqchip/irq-gic.c
 mode change 100644 => 100755 drivers/of/irq.c
 mode change 100644 => 100755 include/linux/interrupt.h
 mode change 100644 => 100755 include/linux/irq.h
 mode change 100644 => 100755 include/linux/irqdesc.h
 mode change 100644 => 100755 include/linux/irqdomain.h
 mode change 100644 => 100755 include/linux/of.h
 mode change 100644 => 100755 kernel/irq/chip.c
 mode change 100644 => 100755 kernel/irq/handle.c
 mode change 100644 => 100755 kernel/irq/irqdesc.c
 mode change 100644 => 100755 kernel/irq/irqdomain.c
 mode change 100644 => 100755 kernel/irq/manage.c
 mode change 100644 => 100755 kernel/irq/resend.c
 mode change 100644 => 100755 kernel/irq/spurious.c

diff --git a/arch/arm/include/asm/irq.h b/arch/arm/include/asm/irq.h
old mode 100644
new mode 100755
index be1d07d5..ec9d2a98
--- a/arch/arm/include/asm/irq.h
+++ b/arch/arm/include/asm/irq.h
@@ -31,6 +31,10 @@ void handle_IRQ(unsigned int, struct pt_regs *);
 void init_IRQ(void);
 
 #ifdef CONFIG_MULTI_IRQ_HANDLER
+/**
+ * 处理中断的入口函数，由汇编直接调进来
+ * 对GIC-V2来说，就是gic_handle_irq
+ */
 extern void (*handle_arch_irq)(struct pt_regs *);
 extern void set_handle_irq(void (*handle_irq)(struct pt_regs *));
 #endif
diff --git a/drivers/irqchip/irq-gic.c b/drivers/irqchip/irq-gic.c
old mode 100644
new mode 100755
index 982c09c2..3258a3de
--- a/drivers/irqchip/irq-gic.c
+++ b/drivers/irqchip/irq-gic.c
@@ -312,31 +312,44 @@ static int gic_set_affinity(struct irq_data *d, const struct cpumask *mask_val,
 }
 #endif
 
+/**
+ * GIC中断控制器入口
+ */
 static void __exception_irq_entry gic_handle_irq(struct pt_regs *regs)
 {
 	u32 irqstat, irqnr;
+	//获得root GIC的硬件描述符
 	struct gic_chip_data *gic = &gic_data[0];
+	//获得GIC io映射地址
 	void __iomem *cpu_base = gic_data_cpu_base(gic);
 
 	do {
+		//获得HW中断号
 		irqstat = readl_relaxed(cpu_base + GIC_CPU_INTACK);
 		irqnr = irqstat & GICC_IAR_INT_ID_MASK;
 
+		//SPI或者PPI
 		if (likely(irqnr > 15 && irqnr < 1021)) {
 			if (static_key_true(&supports_deactivate))
 				writel_relaxed(irqstat, cpu_base + GIC_CPU_EOI);
+			//处理通常的域中火情
 			handle_domain_irq(gic->domain, irqnr, regs);
 			continue;
 		}
+		//IPI
 		if (irqnr < 16) {
+			//直接应答
 			writel_relaxed(irqstat, cpu_base + GIC_CPU_EOI);
 			if (static_key_true(&supports_deactivate))
 				writel_relaxed(irqstat, cpu_base + GIC_CPU_DEACTIVATE);
 #ifdef CONFIG_SMP
+			//处理IPI
 			handle_IPI(irqnr, regs);
 #endif
+			//继续读取硬件，看是否还有新的中断到来
 			continue;
 		}
+		//没有中断了，退出。
 		break;
 	} while (1);
 }
@@ -1040,16 +1053,30 @@ static void __init __gic_init_bases(unsigned int gic_nr, int irq_start,
 		 * For primary GICs, skip over SGIs.
 		 * For secondary GICs, skip over PPIs, too.
 		 */
-		if (gic_nr == 0 && (irq_start & 31) > 0) {
+		if (gic_nr == 0 && (irq_start & 31) > 0) {/* Root GIC */
+			/**
+			 * 系统支持的所有的中断数目－16。
+			 * 之所以减去16主要是因为root GIC的0～15号HW interrupt 是for IPI的，因此要去掉。也正因为如此hwirq_base从16开始
+			 */
 			hwirq_base = 16;
 			if (irq_start != -1)
 				irq_start = (irq_start & ~31) + 16;
-		} else {
+		} else {/* second GIC */
+			/**
+			 * 对于second GIC
+			 * 其0～15号HW interrupt 是for IPI的，因此要去掉。
+			 * 而16～31号HW interrupt 是for PPI的，也要去掉。
+			 * 也正因为如此hwirq_base从32开始
+			 */
 			hwirq_base = 32;
 		}
 
 		gic_irqs -= hwirq_base; /* calculate # of irqs to allocate */
 
+		/**
+		 * 对root gic来说，从16号开始搜索IRQ number
+		 * 对second gic来说，只能从root后面找到可用IRQ Number了。
+		 */
 		irq_base = irq_alloc_descs(irq_start, 16, gic_irqs,
 					   numa_node_id());
 		if (IS_ERR_VALUE(irq_base)) {
@@ -1058,6 +1085,17 @@ static void __init __gic_init_bases(unsigned int gic_nr, int irq_start,
 			irq_base = irq_start;
 		}
 
+		/**
+		 * 向系统注册irq domain并创建映射
+		 *	for root gic:
+		 *		16->16
+		 *		17->17
+		 *		more....
+		 *	for second gic:
+		 *		irq + 1->33
+		 *		irq + 2->34
+		 *		more....
+		 */
 		gic->domain = irq_domain_add_legacy(node, gic_irqs, irq_base,
 					hwirq_base, &gic_irq_domain_ops, gic);
 	}
@@ -1065,6 +1103,7 @@ static void __init __gic_init_bases(unsigned int gic_nr, int irq_start,
 	if (WARN_ON(!gic->domain))
 		return;
 
+	//root GIC
 	if (gic_nr == 0) {
 		/*
 		 * Initialize the CPU interface map to all CPUs.
@@ -1077,6 +1116,10 @@ static void __init __gic_init_bases(unsigned int gic_nr, int irq_start,
 		set_smp_cross_call(gic_raise_softirq);
 		register_cpu_notifier(&gic_cpu_notifier);
 #endif
+		/**
+		 * 设置中断处理函数
+		 * 汇编中直接进入gic_handle_irq
+		 */
 		set_handle_irq(gic_handle_irq);
 		if (static_key_true(&supports_deactivate))
 			pr_info("GIC: Using split EOI/Deactivate mode\n");
@@ -1141,6 +1184,9 @@ static bool gic_check_eoimode(struct device_node *node, void __iomem **base)
 	return true;
 }
 
+/**
+ * GIC-V2中断控制器驱动入口。
+ */
 static int __init
 gic_of_init(struct device_node *node, struct device_node *parent)
 {
@@ -1172,8 +1218,17 @@ gic_of_init(struct device_node *node, struct device_node *parent)
 	if (!gic_cnt)
 		gic_init_physaddr(node);
 
+	//second gic
 	if (parent) {
+		/**
+		 * 解析second GIC的interrupts属性，并进行mapping
+		 * 返回IRQ number
+		 */
 		irq = irq_of_parse_and_map(node, 0);
+		/**
+		 * 对级联irq要单独设置其Handle
+		 * 并且驱动不同修改这个Handle
+		 */
 		gic_cascade_irq(gic_cnt, irq);
 	}
 
diff --git a/drivers/of/irq.c b/drivers/of/irq.c
old mode 100644
new mode 100755
index 55317fa9..73af4cd3
--- a/drivers/of/irq.c
+++ b/drivers/of/irq.c
@@ -35,13 +35,21 @@
  * This function is a wrapper that chains of_irq_parse_one() and
  * irq_create_of_mapping() to make things easier to callers
  */
+/**
+ * 根据DT设置
+ * 构建HW中断与逻辑中断之间的映射关系
+ */
 unsigned int irq_of_parse_and_map(struct device_node *dev, int index)
 {
 	struct of_phandle_args oirq;
 
+	/**
+	 * 分析DT表第index项的属性
+	 */
 	if (of_irq_parse_one(dev, index, &oirq))
 		return 0;
 
+	//根据DT创建映射
 	return irq_create_of_mapping(&oirq);
 }
 EXPORT_SYMBOL_GPL(irq_of_parse_and_map);
@@ -483,6 +491,11 @@ struct of_intc_desc {
  * This function scans the device tree for matching interrupt controller nodes,
  * and calls their initialization functions in order with parents first.
  */
+/**
+ * 在dtb中扫描中断控制器节点
+ * 并从root开始，分层次调用驱动进行初始化。
+ * 对GIC-V2来说，会调用gic_of_init
+ */
 void __init of_irq_init(const struct of_device_id *matches)
 {
 	struct device_node *np, *parent = NULL;
diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
old mode 100644
new mode 100755
index f868e88f..53907b92
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -26,6 +26,9 @@
  * setting should be assumed to be "as already configured", which
  * may be as per machine or firmware initialisation.
  */
+/**
+ * 中断触发类型
+ */
 #define IRQF_TRIGGER_NONE	0x00000000
 #define IRQF_TRIGGER_RISING	0x00000001
 #define IRQF_TRIGGER_FALLING	0x00000002
@@ -62,15 +65,43 @@
  *                wakeup devices users need to implement wakeup detection in
  *                their interrupt handlers.
  */
+/**
+ * 是否允许在设备间共享???
+ */
 #define IRQF_SHARED		0x00000080
+/**
+ * 仅仅是尝试一下是否能够共享
+ * 内核别报警
+ */
 #define IRQF_PROBE_SHARED	0x00000100
 #define __IRQF_TIMER		0x00000200
+/**
+ * 该中断是否是每CPU中断，如Local timer
+ */
 #define IRQF_PERCPU		0x00000400
+/**
+ * 是否参与IRQ负载平衡
+ */
 #define IRQF_NOBALANCING	0x00000800
 #define IRQF_IRQPOLL		0x00001000
+/**
+ * 一次性的，不能嵌套
+ * 重入问题
+ */
 #define IRQF_ONESHOT		0x00002000
+/**
+ * Suspend的时候，别挂起这个中断
+ */
 #define IRQF_NO_SUSPEND		0x00004000
+/**
+ * 唤醒的时候，必须要强制唤醒本中断
+ * 即使有IRQF_NO_SUSPEND标志也是如此
+ */
 #define IRQF_FORCE_RESUME	0x00008000
+/**
+ * 别线程化这些中断，即使强制线程化功能打开也是如此
+ * 如Timer、级联中断。
+ */
 #define IRQF_NO_THREAD		0x00010000
 #define IRQF_EARLY_RESUME	0x00020000
 #define IRQF_COND_SUSPEND	0x00040000
@@ -128,6 +159,10 @@ request_threaded_irq(unsigned int irq, irq_handler_t handler,
 		     irq_handler_t thread_fn,
 		     unsigned long flags, const char *name, void *dev);
 
+/**
+ * 用于与老接口兼容
+ * 旧驱动使用
+ */
 static inline int __must_check
 request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
 	    const char *name, void *dev)
diff --git a/include/linux/irq.h b/include/linux/irq.h
old mode 100644
new mode 100755
index 56239dff..35e01052
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -369,24 +369,36 @@ static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)
  * @irq_set_vcpu_affinity:	optional to target a vCPU in a virtual machine
  * @flags:		chip specific flags
  */
+/**
+ * 中断控制器
+ */
 struct irq_chip {
+	//控制器名称
 	const char	*name;
+	//打开关闭中断，不指定的话，就调用irq_enable
 	unsigned int	(*irq_startup)(struct irq_data *data);
 	void		(*irq_shutdown)(struct irq_data *data);
 	void		(*irq_enable)(struct irq_data *data);
 	void		(*irq_disable)(struct irq_data *data);
 
+	//应答中断
 	void		(*irq_ack)(struct irq_data *data);
+	//屏蔽中断
 	void		(*irq_mask)(struct irq_data *data);
 	void		(*irq_mask_ack)(struct irq_data *data);
 	void		(*irq_unmask)(struct irq_data *data);
+	//结束中断
 	void		(*irq_eoi)(struct irq_data *data);
 
+	//设置irq亲和性
 	int		(*irq_set_affinity)(struct irq_data *data, const struct cpumask *dest, bool force);
+	//在中断丢失的情况下，重新触发中断
 	int		(*irq_retrigger)(struct irq_data *data);
+	//设置中断触发方式
 	int		(*irq_set_type)(struct irq_data *data, unsigned int flow_type);
 	int		(*irq_set_wake)(struct irq_data *data, unsigned int on);
 
+	//锁定总线
 	void		(*irq_bus_lock)(struct irq_data *data);
 	void		(*irq_bus_sync_unlock)(struct irq_data *data);
 
diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
old mode 100644
new mode 100755
index 5e45d1e5..143c72b2
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -52,7 +52,11 @@ struct irq_desc {
 	struct irq_data		irq_data;
 	//中断在每个CPU上的执行状态
 	unsigned int __percpu	*kstat_irqs;
-	//高级irq事件事件??
+	/**
+	 * 高级irq事件事件
+	 * 即高级事件处理回调
+	 * 如边缘、电平两种方式的中断有不同的处理方式。
+	 */
 	irq_flow_handler_t	handle_irq;
 #ifdef CONFIG_IRQ_PREFLOW_FASTEOI
 	//arm上未用
@@ -62,10 +66,11 @@ struct irq_desc {
 	struct irqaction	*action;	/* IRQ action list */
 	//和irq_common_data中的状态有什么区别?
 	unsigned int		status_use_accessors;
+	//内部状态，别动
 	unsigned int		core_internal_state__do_not_mess_with_it;
 	//禁止该中断的次数
 	unsigned int		depth;		/* nested irq disables */
-	//打开该中断的次数
+	//唤醒该中断的次数，用于电源管理
 	unsigned int		wake_depth;	/* nested wake enables */
 	//发生的中断次数，用于检测硬件故障。
 	unsigned int		irq_count;	/* For detecting broken IRQs */
@@ -78,6 +83,7 @@ struct irq_desc {
 	int			threads_handled_last;
 	//保护该数据结构的自旋锁
 	raw_spinlock_t		lock;
+	//在哪些核上面打开此中断
 	struct cpumask		*percpu_enabled;
 #ifdef CONFIG_SMP
 	const struct cpumask	*affinity_hint;
diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
old mode 100644
new mode 100755
index f644fdb0..5d45e272
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -74,11 +74,30 @@ enum irq_domain_bus_token {
  * whatever internal data structures management is required. It also needs
  * to setup the irq_desc when returning from map().
  */
+/**
+ * irq_domain回调函数表
+ */
 struct irq_domain_ops {
+	/**
+	 * 判断某个irq_domain与控制器是否匹配
+	 * 一般不实现
+	 * 默认情况下，判断irq_domain的of_node是否与node相等就行了。
+	 */
 	int (*match)(struct irq_domain *d, struct device_node *node,
 		     enum irq_domain_bus_token bus_token);
+	/**
+	 * 在建立HW中断与逻辑中断关联时
+	 * 由此函数进行:
+	 *		1、设置中断描述符的irq-chip
+	 *		2、根据中断类型设置高级处理函数
+	 *		3、设置中断描述符irq-chipdata
+	 */
 	int (*map)(struct irq_domain *d, unsigned int virq, irq_hw_number_t hw);
 	void (*unmap)(struct irq_domain *d, unsigned int virq);
+	/**
+	 * 根据设备设置属性
+	 * 解析某个硬件的逻辑中断号，中断类型
+	 */
 	int (*xlate)(struct irq_domain *d, struct device_node *node,
 		     const u32 *intspec, unsigned int intsize,
 		     unsigned long *out_hwirq, unsigned int *out_type);
@@ -122,14 +141,21 @@ struct irq_domain_chip_generic;
  * @revmap_tree: Radix map tree for hwirqs that don't fit in the linear map
  * @linear_revmap: Linear table of hwirq->virq reverse mappings
  */
+/**
+ * 硬件中断与逻辑中断管理域
+ */
 struct irq_domain {
+	//通过此结构将描述符链接到全局链表irq_domain_list中
 	struct list_head link;
 	const char *name;
+	//回调函数
 	const struct irq_domain_ops *ops;
+	//中断控制器私有数据，如gic_chip_data
 	void *host_data;
 	unsigned int flags;
 
 	/* Optional data */
+	//中断控制器的DT节点
 	struct device_node *of_node;
 	enum irq_domain_bus_token bus_token;
 	struct irq_domain_chip_generic *gc;
@@ -138,10 +164,22 @@ struct irq_domain {
 #endif
 
 	/* reverse map data. The linear map gets appended to the irq_domain */
+	//最大硬中断号
 	irq_hw_number_t hwirq_max;
+	//对线性映射来说，此值未用
 	unsigned int revmap_direct_max_irq;
+	/**
+	 * 线性映射的大小
+	 * 对基树来说，其值为0
+	 */
 	unsigned int revmap_size;
+	/**
+	 * 基树映射用到的根节点
+	 */
 	struct radix_tree_root revmap_tree;
+	/**
+	 * 线性映射使用的映射表
+	 */
 	unsigned int linear_revmap[];
 };
 
@@ -198,6 +236,12 @@ static inline struct irq_domain *irq_find_host(struct device_node *node)
  * @ops: map/unmap domain callbacks
  * @host_data: Controller private data pointer
  */
+/**
+ * 向线性映射表中添加映射
+ *	size:			该线性映射表支持多少irq
+ *	ops:			callback函数
+ *	host_data:	driver私有数据
+ */
 static inline struct irq_domain *irq_domain_add_linear(struct device_node *of_node,
 					 unsigned int size,
 					 const struct irq_domain_ops *ops,
@@ -205,6 +249,10 @@ static inline struct irq_domain *irq_domain_add_linear(struct device_node *of_no
 {
 	return __irq_domain_add(of_node, size, size, 0, ops, host_data);
 }
+/**
+ * 对于PowerPC PMIC控制器，其硬件中断号可自由配置
+ * 此时不需要软件进行二次映射
+ */
 static inline struct irq_domain *irq_domain_add_nomap(struct device_node *of_node,
 					 unsigned int max_irq,
 					 const struct irq_domain_ops *ops,
@@ -220,6 +268,10 @@ static inline struct irq_domain *irq_domain_add_legacy_isa(
 	return irq_domain_add_legacy(of_node, NUM_ISA_INTERRUPTS, 0, 0, ops,
 				     host_data);
 }
+/**
+ * 向基树映射表中添加映射关系
+ * PowerPC和MIPS平台使用此函数
+ */
 static inline struct irq_domain *irq_domain_add_tree(struct device_node *of_node,
 					 const struct irq_domain_ops *ops,
 					 void *host_data)
diff --git a/include/linux/of.h b/include/linux/of.h
old mode 100644
new mode 100755
index 2194b8ca..46bec994
--- a/include/linux/of.h
+++ b/include/linux/of.h
@@ -69,9 +69,15 @@ struct device_node {
 };
 
 #define MAX_PHANDLE_ARGS 16
+/**
+ * phandle及其参数
+ */
 struct of_phandle_args {
+	/* 设备节点 */
 	struct device_node *np;
+	/* phandle参数个数 */
 	int args_count;
+	/* 所有参数 */
 	uint32_t args[MAX_PHANDLE_ARGS];
 };
 
diff --git a/kernel/irq/chip.c b/kernel/irq/chip.c
old mode 100644
new mode 100755
index 652ee613..42afcbab
--- a/kernel/irq/chip.c
+++ b/kernel/irq/chip.c
@@ -436,25 +436,37 @@ static void cond_unmask_irq(struct irq_desc *desc)
 void handle_level_irq(struct irq_desc *desc)
 {
 	raw_spin_lock(&desc->lock);
+	/**
+	 * 电平中断需要mask_and_ack
+	 * 直到EIO之后再unmask
+	 * 否则中断会不停的到达，形成伪中断
+	 */
 	mask_ack_irq(desc);
 
 	if (!irq_may_run(desc))
 		goto out_unlock;
 
+	//电平中断不需要重新触发
 	desc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);
+	//中断计数
 	kstat_incr_irqs_this_cpu(desc);
 
 	/*
 	 * If its disabled or no action available
 	 * keep it masked and get out of here
 	 */
+	/**
+	 * 中断被禁止了，等待重新触发
+	 */
 	if (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {
 		desc->istate |= IRQS_PENDING;
 		goto out_unlock;
 	}
 
+	//调用ISR
 	handle_irq_event(desc);
 
+	//如果没有被禁止，就UNMASK
 	cond_unmask_irq(desc);
 
 out_unlock:
@@ -556,10 +568,17 @@ EXPORT_SYMBOL_GPL(handle_fasteoi_irq);
  *	the handler was running. If all pending interrupts are handled, the
  *	loop is left.
  */
+/**
+ * 边缘触发的中断处理函数
+ */
 void handle_edge_irq(struct irq_desc *desc)
 {
 	raw_spin_lock(&desc->lock);
 
+	/**
+	 * IRQS_REPLAY:重新触发，此处需要清除
+	 * IRQS_WAITING:与中断探测相关
+	 */
 	desc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);
 
 	if (!irq_may_run(desc)) {
@@ -572,19 +591,30 @@ void handle_edge_irq(struct irq_desc *desc)
 	 * If its disabled or no action available then mask it and get
 	 * out of here.
 	 */
+	/**
+	 * 中断被其他核禁止了
+	 * 或者没有设置ISR
+	 */
 	if (irqd_irq_disabled(&desc->irq_data) || !desc->action) {
+		/**
+		 * 重新触发，等待重新打开的时候弥补一下
+		 */
 		desc->istate |= IRQS_PENDING;
 		mask_ack_irq(desc);
 		goto out_unlock;
 	}
 
+	//更新IRQ统计信息
 	kstat_incr_irqs_this_cpu(desc);
 
 	/* Start handling the irq */
+	//应答中断
 	desc->irq_data.chip->irq_ack(&desc->irq_data);
 
 	do {
+		//这里需要再次判断一下
 		if (unlikely(!desc->action)) {
+			//没有ISR，需要将中断Mask掉
 			mask_irq(desc);
 			goto out_unlock;
 		}
@@ -594,14 +624,20 @@ void handle_edge_irq(struct irq_desc *desc)
 		 * one, we could have masked the irq.
 		 * Renable it, if it was not disabled in meantime.
 		 */
+		/* 其他核上面收到了同一个中断 */
 		if (unlikely(desc->istate & IRQS_PENDING)) {
 			if (!irqd_irq_disabled(&desc->irq_data) &&
 			    irqd_irq_masked(&desc->irq_data))
+			    //重新打开中断
 				unmask_irq(desc);
 		}
 
+		//调用ISR处理中断
 		handle_irq_event(desc);
 
+	/**
+	 * 再次触发了中断，本核继续处理
+	 */
 	} while ((desc->istate & IRQS_PENDING) &&
 		 !irqd_irq_disabled(&desc->irq_data));
 
@@ -754,6 +790,10 @@ __irq_do_set_handler(struct irq_desc *desc, irq_flow_handler_t handle,
 	desc->handle_irq = handle;
 	desc->name = name;
 
+	/**
+	 * 这里需要注意
+	 * 对于级联irq，要特殊处理一下
+	 */
 	if (handle != handle_bad_irq && is_chained) {
 		irq_settings_set_noprobe(desc);
 		irq_settings_set_norequest(desc);
diff --git a/kernel/irq/handle.c b/kernel/irq/handle.c
old mode 100644
new mode 100755
index e25a83b6..89afa02e
--- a/kernel/irq/handle.c
+++ b/kernel/irq/handle.c
@@ -187,12 +187,16 @@ irqreturn_t handle_irq_event(struct irq_desc *desc)
 	struct irqaction *action = desc->action;
 	irqreturn_t ret;
 
+	//在打开锁之前，需要标记这两个标志
 	desc->istate &= ~IRQS_PENDING;
 	irqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);
+	//打开中断描述符的锁
 	raw_spin_unlock(&desc->lock);
 
+	//调用ISR
 	ret = handle_irq_event_percpu(desc, action);
 
+	//再次获得锁并清除IRQD_IRQ_INPROGRESS标志
 	raw_spin_lock(&desc->lock);
 	irqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);
 	return ret;
diff --git a/kernel/irq/irqdesc.c b/kernel/irq/irqdesc.c
old mode 100644
new mode 100755
index 786689d6..e3ebfcbe
--- a/kernel/irq/irqdesc.c
+++ b/kernel/irq/irqdesc.c
@@ -256,6 +256,9 @@ int __init early_irq_init(void)
 
 #else /* !CONFIG_SPARSE_IRQ */
 
+/**
+ * 系统中所有中断描述符
+ */
 struct irq_desc irq_desc[NR_IRQS] __cacheline_aligned_in_smp = {
 	[0 ... NR_IRQS-1] = {
 		.handle_irq	= handle_bad_irq,
@@ -390,6 +393,7 @@ int __handle_domain_irq(struct irq_domain *domain, unsigned int hwirq,
 
 #ifdef CONFIG_IRQ_DOMAIN
 	if (lookup)
+		//HW中断号转逻辑中断号
 		irq = irq_find_mapping(domain, hwirq);
 #endif
 
diff --git a/kernel/irq/irqdomain.c b/kernel/irq/irqdomain.c
old mode 100644
new mode 100755
index dc9d27c0..77fdc652
--- a/kernel/irq/irqdomain.c
+++ b/kernel/irq/irqdomain.c
@@ -17,6 +17,9 @@
 #include <linux/smp.h>
 #include <linux/fs.h>
 
+/**
+ * 所有irq_domain的全局链表
+ */
 static LIST_HEAD(irq_domain_list);
 static DEFINE_MUTEX(irq_domain_mutex);
 
@@ -177,9 +180,13 @@ struct irq_domain *irq_domain_add_legacy(struct device_node *of_node,
 {
 	struct irq_domain *domain;
 
+	/**
+	 * 注册irq_domain
+	 */
 	domain = __irq_domain_add(of_node, first_hwirq + size,
 				  first_hwirq + size, 0, ops, host_data);
 	if (domain)
+		/* 创建HW中断与逻辑中断之间的映射 */
 		irq_domain_associate_many(domain, first_irq, first_hwirq, size);
 
 	return domain;
@@ -278,6 +285,9 @@ void irq_domain_disassociate(struct irq_domain *domain, unsigned int irq)
 	}
 }
 
+/**
+ * 建立逻辑中断与HW中断之间的映射
+ */
 int irq_domain_associate(struct irq_domain *domain, unsigned int virq,
 			 irq_hw_number_t hwirq)
 {
@@ -292,12 +302,16 @@ int irq_domain_associate(struct irq_domain *domain, unsigned int virq,
 	if (WARN(irq_data->domain, "error: virq%i is already associated", virq))
 		return -EINVAL;
 
+	//获取irq_domain的锁
 	mutex_lock(&irq_domain_mutex);
 	irq_data->hwirq = hwirq;
 	irq_data->domain = domain;
-	if (domain->ops->map) {
+	if (domain->ops->map) {/* 定义了map函数 */
+		/**
+		 * 调用irq domain的map callback函数
+		 */
 		ret = domain->ops->map(domain, virq, hwirq);
-		if (ret != 0) {
+		if (ret != 0) {/* 失败了 */
 			/*
 			 * If map() returns -EPERM, this interrupt is protected
 			 * by the firmware or some other service and shall not
@@ -307,26 +321,34 @@ int irq_domain_associate(struct irq_domain *domain, unsigned int virq,
 				pr_info("%s didn't like hwirq-0x%lx to VIRQ%i mapping (rc=%d)\n",
 				       domain->name, hwirq, virq, ret);
 			}
+			//清除irq_data字段
 			irq_data->domain = NULL;
 			irq_data->hwirq = 0;
+			//解锁返回
 			mutex_unlock(&irq_domain_mutex);
 			return ret;
 		}
 
 		/* If not already assigned, give the domain the chip's name */
+		/* 给一个默认值 */
 		if (!domain->name && irq_data->chip)
 			domain->name = irq_data->chip->name;
 	}
 
+	//线性映射
 	if (hwirq < domain->revmap_size) {
+		//直接设置线性映射的转换
 		domain->linear_revmap[hwirq] = virq;
-	} else {
+	} else {/* 基树映射 */
+		//获得基树锁
 		mutex_lock(&revmap_trees_mutex);
+		//将其插入基树
 		radix_tree_insert(&domain->revmap_tree, hwirq, irq_data);
 		mutex_unlock(&revmap_trees_mutex);
 	}
 	mutex_unlock(&irq_domain_mutex);
 
+	//已经映射了，置标志表示把坑占住
 	irq_clear_status_flags(virq, IRQ_NOREQUEST);
 
 	return 0;
@@ -396,6 +418,10 @@ EXPORT_SYMBOL_GPL(irq_create_direct_mapping);
  * If the sense/trigger is to be specified, set_irq_type() should be called
  * on the number returned from that call.
  */
+/**
+ * 在irq_domain中，为单个HW中断建立映射
+ * 返回其逻辑中断号
+ */
 unsigned int irq_create_mapping(struct irq_domain *domain,
 				irq_hw_number_t hwirq)
 {
@@ -413,13 +439,16 @@ unsigned int irq_create_mapping(struct irq_domain *domain,
 	pr_debug("-> using domain @%p\n", domain);
 
 	/* Check if mapping already exists */
+	// 如果映射已经存在
 	virq = irq_find_mapping(domain, hwirq);
 	if (virq) {
+		//那么不需要映射，直接返回
 		pr_debug("-> existing mapping on virq %d\n", virq);
 		return virq;
 	}
 
 	/* Allocate a virtual interrupt number */
+	//分配一个IRQ 描述符以及对应的irq number
 	virq = irq_domain_alloc_descs(-1, 1, hwirq,
 				      of_node_to_nid(domain->of_node));
 	if (virq <= 0) {
@@ -427,6 +456,7 @@ unsigned int irq_create_mapping(struct irq_domain *domain,
 		return 0;
 	}
 
+	//建立HW中断号与逻辑中断号之间的映射
 	if (irq_domain_associate(domain, virq, hwirq)) {
 		irq_free_desc(virq);
 		return 0;
@@ -457,6 +487,9 @@ EXPORT_SYMBOL_GPL(irq_create_mapping);
  * 0 is returned upon success, while any failure to establish a static
  * mapping is treated as an error.
  */
+/**
+ * 为一组HW中断号建立逻辑中断映射
+ */
 int irq_create_strict_mappings(struct irq_domain *domain, unsigned int irq_base,
 			       irq_hw_number_t hwirq_base, int count)
 {
@@ -472,6 +505,10 @@ int irq_create_strict_mappings(struct irq_domain *domain, unsigned int irq_base,
 }
 EXPORT_SYMBOL_GPL(irq_create_strict_mappings);
 
+/**
+ * 通过DT表中的设置
+ * 建立HW中断号与逻辑中断号之间的映射
+ */
 unsigned int irq_create_of_mapping(struct of_phandle_args *irq_data)
 {
 	struct irq_domain *domain;
@@ -479,6 +516,9 @@ unsigned int irq_create_of_mapping(struct of_phandle_args *irq_data)
 	unsigned int type = IRQ_TYPE_NONE;
 	int virq;
 
+	/**
+	 * 查找设备节点对应的irq_domain
+	 */
 	domain = irq_data->np ? irq_find_host(irq_data->np) : irq_default_domain;
 	if (!domain) {
 		pr_warn("no irq domain found for %s !\n",
@@ -487,14 +527,22 @@ unsigned int irq_create_of_mapping(struct of_phandle_args *irq_data)
 	}
 
 	/* If domain has no translation, then we assume interrupt line */
+	//没有定义xlate转换函数
 	if (domain->ops->xlate == NULL)
+		//取interrupts属性的第一个cell作为HW
 		hwirq = irq_data->args[0];
 	else {
+		/**
+		 * 交给驱动来创建映射关系
+		 * cells里面是硬件中断号
+		 * 输出是逻辑中断号，以及其中断类型
+		 */
 		if (domain->ops->xlate(domain, irq_data->np, irq_data->args,
 					irq_data->args_count, &hwirq, &type))
 			return 0;
 	}
 
+	//运行到这里，说明没有定义转换函数
 	if (irq_domain_is_hierarchy(domain)) {
 		/*
 		 * If we've already configured this interrupt,
@@ -509,6 +557,7 @@ unsigned int irq_create_of_mapping(struct of_phandle_args *irq_data)
 			return 0;
 	} else {
 		/* Create mapping */
+		//创建映射
 		virq = irq_create_mapping(domain, hwirq);
 		if (!virq)
 			return virq;
@@ -517,6 +566,7 @@ unsigned int irq_create_of_mapping(struct of_phandle_args *irq_data)
 	/* Set type if specified and different than the current one */
 	if (type != IRQ_TYPE_NONE &&
 	    type != irq_get_trigger_type(virq))
+	    	//设置中断类型
 		irq_set_irq_type(virq, type);
 	return virq;
 }
diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
old mode 100644
new mode 100755
index f9a59f6c..3f99340e
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -1041,8 +1041,13 @@ __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)
 	 * Check whether the interrupt nests into another interrupt
 	 * thread.
 	 */
+	/**
+	 * 嵌套中断，handle_nested_irq中唤醒线程来处理
+	 * IO expander上面的慢速 中断
+	 */
 	nested = irq_settings_is_nested_thread(desc);
 	if (nested) {
+		/* 嵌套中断必须要附着在线程上处理 */
 		if (!new->thread_fn) {
 			ret = -EINVAL;
 			goto out_mput;
@@ -1052,8 +1057,12 @@ __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)
 		 * the driver for non nested interrupt handling by the
 		 * dummy function which warns when called.
 		 */
+		/**
+		 * 警告，二传手直接唤醒线程
+		 */
 		new->handler = irq_nested_primary_handler;
 	} else {
+		/* 如果允许强制线程化，就把主处理函数也线程化了 */
 		if (irq_settings_can_thread(desc))
 			irq_setup_forced_threading(new);
 	}
@@ -1063,12 +1072,15 @@ __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)
 	 * and the interrupt does not nest into another interrupt
 	 * thread.
 	 */
-	if (new->thread_fn && !nested) {
+	if (new->thread_fn && !nested) {/* 需要创建线程 */
 		struct task_struct *t;
 		static const struct sched_param param = {
 			.sched_priority = MAX_USER_RT_PRIO/2,
 		};
 
+		/**
+		 * 创建中断线程
+		 */
 		t = kthread_create(irq_thread, new, "irq/%d-%s", irq,
 				   new->name);
 		if (IS_ERR(t)) {
@@ -1076,6 +1088,7 @@ __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)
 			goto out_mput;
 		}
 
+		//设置线程为实时线程
 		sched_setscheduler_nocheck(t, SCHED_FIFO, &param);
 
 		/*
@@ -1083,6 +1096,7 @@ __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)
 		 * the thread dies to avoid that the interrupt code
 		 * references an already freed task_struct.
 		 */
+		//中断描述符需要引用这个线程对象
 		get_task_struct(t);
 		new->thread = t;
 		/*
@@ -1097,6 +1111,7 @@ __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)
 		set_bit(IRQTF_AFFINITY, &new->thread_flags);
 	}
 
+	//mask用于线程亲和性，与中断亲和性相关
 	if (!alloc_cpumask_var(&mask, GFP_KERNEL)) {
 		ret = -ENOMEM;
 		goto out_thread;
@@ -1111,6 +1126,10 @@ __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)
 	 * chip flags, so we can avoid the unmask dance at the end of
 	 * the threaded handler for those.
 	 */
+	/**
+	 * 如果中断控制器本身已经保证中断不重入了
+	 * 那就可以去掉IRQF_ONESHOT标志
+	 */
 	if (desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)
 		new->flags &= ~IRQF_ONESHOT;
 
@@ -1120,7 +1139,7 @@ __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)
 	raw_spin_lock_irqsave(&desc->lock, flags);
 	old_ptr = &desc->action;
 	old = *old_ptr;
-	if (old) {
+	if (old) {/* 存在旧的ISR */
 		/*
 		 * Can't share interrupts unless both agree to and are
 		 * the same type (level, edge, polarity). So both flag
@@ -1128,18 +1147,18 @@ __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)
 		 * set the trigger type must match. Also all must
 		 * agree on ONESHOT.
 		 */
-		if (!((old->flags & new->flags) & IRQF_SHARED) ||
-		    ((old->flags ^ new->flags) & IRQF_TRIGGER_MASK) ||
-		    ((old->flags ^ new->flags) & IRQF_ONESHOT))
+		if (!((old->flags & new->flags) & IRQF_SHARED) ||/* 新旧ISR没有打开共享 */
+		    ((old->flags ^ new->flags) & IRQF_TRIGGER_MASK) ||/* 中断类型不一样 */
+		    ((old->flags ^ new->flags) & IRQF_ONESHOT))/* ONESHOT标志不一样 */
 			goto mismatch;
 
 		/* All handlers must agree on per-cpuness */
 		if ((old->flags & IRQF_PERCPU) !=
-		    (new->flags & IRQF_PERCPU))
+		    (new->flags & IRQF_PERCPU))/* 晕，还有这个 */
 			goto mismatch;
 
 		/* add new interrupt at end of irq queue */
-		do {
+		do {/* 将ISR链接到链表中 */
 			/*
 			 * Or all existing action->thread_mask bits,
 			 * so we can find the next zero bit for this
@@ -1157,12 +1176,17 @@ __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)
 	 * !ONESHOT irqs the thread mask is 0 so we can avoid a
 	 * conditional in irq_wake_thread().
 	 */
-	if (new->flags & IRQF_ONESHOT) {
+	if (new->flags & IRQF_ONESHOT) {/* 对ONESHOT类型的中断来说，还需要设置线程掩码 */
 		/*
 		 * Unlikely to have 32 resp 64 irqs sharing one line,
 		 * but who knows.
 		 */
+		/**
+		 * 线程掩码用完了。
+		 * 有太多的ISR
+		 */
 		if (thread_mask == ~0UL) {
+			/* 不成功，退出 */
 			ret = -EBUSY;
 			goto out_mask;
 		}
@@ -1186,8 +1210,15 @@ __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)
 		 * thread_mask assigned. See the loop above which or's
 		 * all existing action->thread_mask bits.
 		 */
+		/* 找一个可用的掩码 */
 		new->thread_mask = 1 << ffz(thread_mask);
 
+	/**
+	 * irq_default_primary_handler只会唤醒线程
+	 * 而不会让电平信号消失
+	 * 如果中断控制器并不是ONESHOT安全的
+	 * 那么明显有问题
+	 */
 	} else if (new->handler == irq_default_primary_handler &&
 		   !(desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)) {
 		/*
@@ -1207,6 +1238,10 @@ __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)
 		 */
 		pr_err("Threaded irq requested with handler=NULL and !ONESHOT for irq %d\n",
 		       irq);
+		/**
+		 * 调用者应当设置上半部函数
+		 * 以清除电平信号
+		 */
 		ret = -EINVAL;
 		goto out_mask;
 	}
@@ -1526,6 +1561,13 @@ EXPORT_SYMBOL(free_irq);
  *	IRQF_TRIGGER_*		Specify active edge(s) or level
  *
  */
+/**
+ * 注册中断处理函数
+ *	irq:			中断号
+ *	handler:		在中断上下文的处理函数，一般为NULL
+ *	thread_fn:	在线程中的处理函数
+ *	irqflags:		中断标志，如IRQF_SHARED
+ */
 int request_threaded_irq(unsigned int irq, irq_handler_t handler,
 			 irq_handler_t thread_fn, unsigned long irqflags,
 			 const char *devname, void *dev_id)
@@ -1543,29 +1585,43 @@ int request_threaded_irq(unsigned int irq, irq_handler_t handler,
 	 * Also IRQF_COND_SUSPEND only makes sense for shared interrupts and
 	 * it cannot be set along with IRQF_NO_SUSPEND.
 	 */
-	if (((irqflags & IRQF_SHARED) && !dev_id) ||
+	if (((irqflags & IRQF_SHARED) && !dev_id) ||/* 共享中断必须指定设备参数 */
 	    (!(irqflags & IRQF_SHARED) && (irqflags & IRQF_COND_SUSPEND)) ||
-	    ((irqflags & IRQF_NO_SUSPEND) && (irqflags & IRQF_COND_SUSPEND)))
+	    ((irqflags & IRQF_NO_SUSPEND) && (irqflags & IRQF_COND_SUSPEND)))/* 参数冲突 */
 		return -EINVAL;
 
+	/* 获取中断描述符 */
 	desc = irq_to_desc(irq);
 	if (!desc)
 		return -EINVAL;
 
+	/**
+	 * 某些中断号，不能为其安装ISR
+	 * 如级联中断
+	 */
 	if (!irq_settings_can_request(desc) ||
+	/**
+	 * 对于per_cpu中断来说，也不能为其安装ISR
+	 * 这种情况请调用request_percpu_irq
+	 */
 	    WARN_ON(irq_settings_is_per_cpu_devid(desc)))
 		return -EINVAL;
 
+	/**
+	 * 上下半部不能同时为NULL
+	 */
 	if (!handler) {
 		if (!thread_fn)
 			return -EINVAL;
 		handler = irq_default_primary_handler;
 	}
 
+	//分配irqaction结构
 	action = kzalloc(sizeof(struct irqaction), GFP_KERNEL);
-	if (!action)
+	if (!action)/* 哦豁，没有内存了 */
 		return -ENOMEM;
 
+	//初始化irqaction几个字段
 	action->handler = handler;
 	action->thread_fn = thread_fn;
 	action->flags = irqflags;
@@ -1573,10 +1629,11 @@ int request_threaded_irq(unsigned int irq, irq_handler_t handler,
 	action->dev_id = dev_id;
 
 	chip_bus_lock(desc);
+	//将ISR安装到链表中
 	retval = __setup_irq(irq, desc, action);
 	chip_bus_sync_unlock(desc);
 
-	if (retval)
+	if (retval)/* 安装不成功，算球了，释放内存 */
 		kfree(action);
 
 #ifdef CONFIG_DEBUG_SHIRQ_FIXME
diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
old mode 100644
new mode 100755
index b86886be..80e86f2c
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -53,6 +53,9 @@ static DECLARE_TASKLET(resend_tasklet, resend_irqs, 0);
  *
  * Is called with interrupts disabled and desc->lock held.
  */
+/**
+ * 检查是否需要重新触发中断
+ */
 void check_irq_resend(struct irq_desc *desc)
 {
 	/*
@@ -61,18 +64,35 @@ void check_irq_resend(struct irq_desc *desc)
 	 * active. Clear the pending bit so suspend/resume does not
 	 * get confused.
 	 */
+	/**
+	 * 电平中断不存在此问题
+	 */
 	if (irq_settings_is_level(desc)) {
 		desc->istate &= ~IRQS_PENDING;
 		return;
 	}
+	/**
+	 * 已经设置了重新触发标志，退出
+	 * 这个标志是由enable、disable设置的。
+	 */
 	if (desc->istate & IRQS_REPLAY)
 		return;
+	/**
+	 * 其他核上面检测到了中断挂起
+	 * 在本核上面重新触发一下。
+	 */
 	if (desc->istate & IRQS_PENDING) {
 		desc->istate &= ~IRQS_PENDING;
+		//设置重新触发标志
 		desc->istate |= IRQS_REPLAY;
 
+		/**
+		 * 硬件不支持重新触发
+		 * 或者触发不成功
+		 */
 		if (!desc->irq_data.chip->irq_retrigger ||
 		    !desc->irq_data.chip->irq_retrigger(&desc->irq_data)) {
+		    //只好由软件来模拟了。
 #ifdef CONFIG_HARDIRQS_SW_RESEND
 			unsigned int irq = irq_desc_get_irq(desc);
 
diff --git a/kernel/irq/spurious.c b/kernel/irq/spurious.c
old mode 100644
new mode 100755
index 32144175..47993bc5
--- a/kernel/irq/spurious.c
+++ b/kernel/irq/spurious.c
@@ -270,6 +270,10 @@ try_misrouted_irq(unsigned int irq, struct irq_desc *desc,
 
 #define SPURIOUS_DEFERRED	0x80000000
 
+/**
+ * 当一个中断没有被处理时
+ * 调用此函数来识别未处理的原因
+ */
 void note_interrupt(struct irq_desc *desc, irqreturn_t action_ret)
 {
 	unsigned int irq;
-- 
2.25.1

