From db73b0eb2b5b47b4f90efc1d7a30e46822e22836 Mon Sep 17 00:00:00 2001
From: "xie.baoyou" <scxby@163.com>
Date: Tue, 10 Oct 2017 13:44:53 +0800
Subject: [PATCH] =?UTF-8?q?[comment-irq]=20irq=E6=A1=86=E6=9E=B6=E7=AC=AC?=
 =?UTF-8?q?=E4=BA=8C=E9=83=A8=E5=88=86=EF=BC=8C=E4=B8=BB=E8=A6=81=E6=98=AF?=
 =?UTF-8?q?GIC-V2=E7=9B=B8=E5=85=B3=E4=BB=A3=E7=A0=81?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 arch/arm/kernel/entry-armv.S     |  8 ++-
 arch/arm/kernel/setup.c          | 20 +++++--
 drivers/irqchip/irq-gic-common.c |  2 +-
 drivers/irqchip/irq-gic.c        | 89 +++++++++++++++++++++++++++++++-
 4 files changed, 111 insertions(+), 8 deletions(-)
 mode change 100644 => 100755 arch/arm/kernel/entry-armv.S
 mode change 100644 => 100755 arch/arm/kernel/setup.c
 mode change 100644 => 100755 drivers/irqchip/irq-gic-common.c

diff --git a/arch/arm/kernel/entry-armv.S b/arch/arm/kernel/entry-armv.S
old mode 100644
new mode 100755
index 5fa10610..49b625c1
--- a/arch/arm/kernel/entry-armv.S
+++ b/arch/arm/kernel/entry-armv.S
@@ -492,6 +492,9 @@ __irq_usr:
  * 如果在用户态下处理原子操作，此时需要特殊处理。
  */
 	kuser_cmpxchg_check
+/**
+ * 处理中断
+ */
 	irq_handler
 /**
  * 从r9中取得当前进程的threadinfo
@@ -1104,6 +1107,9 @@ vector_\name:
  * 调整返回值
  */
 	.if \correction
+/**
+ * 中断、异常返回值
+ */
 	sub	lr, lr, #\correction
 	.endif
 
@@ -1115,7 +1121,7 @@ vector_\name:
  * 保存r0,lr,和spsr
  * 注意堆栈空间只有几个字节，以后应该会再切换堆栈的。
  */
-	stmia	sp, {r0, lr}		@ save r0, lr
+	stmia	sp, {r0, lr}		@ save r0, lr  /* 这里将r0保存起来，因为r0后面会被破坏 */
 /**
  * 后四位应该是异常时CPU所处的模式
  */
diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
old mode 100644
new mode 100755
index aa31e63e..03fffdff
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -135,14 +135,24 @@ EXPORT_SYMBOL(outer_cache);
  */
 int __cpu_architecture __read_mostly = CPU_ARCH_UNKNOWN;
 
+/**
+ * ARM中断模式栈
+ * 在cpu_init中设置
+ */
 struct stack {
+	//中断栈
 	u32 irq[3];
+	//abt/und/fiq的栈
 	u32 abt[3];
 	u32 und[3];
 	u32 fiq[3];
 } ____cacheline_aligned;
 
 #ifndef CONFIG_CPU_V7M
+/**
+ * 用于中断处理
+ * 在转到SVC模式前，由IRQ模式的汇编使用
+ */
 static struct stack stacks[NR_CPUS];
 #endif
 
@@ -499,10 +509,10 @@ void notrace cpu_init(void)
 	 * 设置各种异常和中断的堆栈入口。
 	 */
 	__asm__ (
-	"msr	cpsr_c, %1\n\t"
-	"add	r14, %0, %2\n\t"
+	"msr	cpsr_c, %1\n\t"/* 进入IRQ模式 */
+	"add	r14, %0, %2\n\t" /* r14是irq中断栈地址 */
 	"mov	sp, r14\n\t"
-	"msr	cpsr_c, %3\n\t"
+	"msr	cpsr_c, %3\n\t" /* 分别进入ABT、UND、FIQ模式，并设置其堆栈 */
 	"add	r14, %0, %4\n\t"
 	"mov	sp, r14\n\t"
 	"msr	cpsr_c, %5\n\t"
@@ -511,7 +521,7 @@ void notrace cpu_init(void)
 	"msr	cpsr_c, %7\n\t"
 	"add	r14, %0, %8\n\t"
 	"mov	sp, r14\n\t"
-	"msr	cpsr_c, %9"
+	"msr	cpsr_c, %9"	/* 退回SVC模式 */
 	    :
 	    : "r" (stk),
 	      PLC (PSR_F_BIT | PSR_I_BIT | IRQ_MODE),
@@ -523,7 +533,7 @@ void notrace cpu_init(void)
 	      PLC (PSR_F_BIT | PSR_I_BIT | FIQ_MODE),
 	      "I" (offsetof(struct stack, fiq[0])),
 	      PLC (PSR_F_BIT | PSR_I_BIT | SVC_MODE)
-	    : "r14");
+	    : "r14");/* clobber list，表示r14会被汇编使用 */
 #endif
 }
 
diff --git a/drivers/irqchip/irq-gic-common.c b/drivers/irqchip/irq-gic-common.c
old mode 100644
new mode 100755
index 9448e391..b2e87db4
--- a/drivers/irqchip/irq-gic-common.c
+++ b/drivers/irqchip/irq-gic-common.c
@@ -98,7 +98,7 @@ void gic_cpu_config(void __iomem *base, void (*sync_access)(void))
 	/*
 	 * Set priority on PPI and SGI interrupts
 	 */
-	for (i = 0; i < 32; i += 4)
+	for (i = 0; i < 32; i += 4)/* 设置优先级，高于门阀值，这样中断才真的到达CPU */
 		writel_relaxed(GICD_INT_DEF_PRI_X4,
 					base + GIC_DIST_PRI + i * 4 / 4);
 
diff --git a/drivers/irqchip/irq-gic.c b/drivers/irqchip/irq-gic.c
index 3258a3de..5de1cba0 100755
--- a/drivers/irqchip/irq-gic.c
+++ b/drivers/irqchip/irq-gic.c
@@ -166,6 +166,9 @@ static int gic_peek_irq(struct irq_data *d, u32 offset)
 	return !!(readl_relaxed(gic_dist_base(d) + offset + (gic_irq(d) / 32) * 4) & mask);
 }
 
+/**
+ * Mask一个中断
+ */
 static void gic_mask_irq(struct irq_data *d)
 {
 	gic_poke_irq(d, GIC_DIST_ENABLE_CLEAR);
@@ -186,11 +189,17 @@ static void gic_eoimode1_mask_irq(struct irq_data *d)
 		gic_poke_irq(d, GIC_DIST_ACTIVE_CLEAR);
 }
 
+/**
+ * UNMASK一个中断
+ */
 static void gic_unmask_irq(struct irq_data *d)
 {
 	gic_poke_irq(d, GIC_DIST_ENABLE_SET);
 }
 
+/**
+ * 结束一个中断
+ */
 static void gic_eoi_irq(struct irq_data *d)
 {
 	writel_relaxed(gic_irq(d), gic_cpu_base(d) + GIC_CPU_EOI);
@@ -254,16 +263,25 @@ static int gic_irq_get_irqchip_state(struct irq_data *d,
 	return 0;
 }
 
+/**
+ * 设置中断类型
+ */
 static int gic_set_type(struct irq_data *d, unsigned int type)
 {
 	void __iomem *base = gic_dist_base(d);
 	unsigned int gicirq = gic_irq(d);
 
 	/* Interrupt configuration for SGIs can't be changed */
+	/**
+	 * SGI不能修改其中断类型，总是边缘触发
+	 */
 	if (gicirq < 16)
 		return -EINVAL;
 
 	/* SPIs have restrictions on the supported types */
+	/**
+	 * SPI只能设置为高电平触发或者边缘触发
+	 */
 	if (gicirq >= 32 && type != IRQ_TYPE_LEVEL_HIGH &&
 			    type != IRQ_TYPE_EDGE_RISING)
 		return -EINVAL;
@@ -285,10 +303,18 @@ static int gic_irq_set_vcpu_affinity(struct irq_data *d, void *vcpu)
 }
 
 #ifdef CONFIG_SMP
+/**
+ * 设置中断亲和性
+ */
 static int gic_set_affinity(struct irq_data *d, const struct cpumask *mask_val,
 			    bool force)
 {
 	void __iomem *reg = gic_dist_base(d) + GIC_DIST_TARGET + (gic_irq(d) & ~3);
+	/**
+	 * 支持8个CPU
+	 * 因此每个Interrupt Processor Targets Registers包含4个中断设置
+	 * 这里计算其位置
+	 */
 	unsigned int cpu, shift = (gic_irq(d) % 4) * 8;
 	u32 val, mask, bit;
 	unsigned long flags;
@@ -427,8 +453,19 @@ static u8 gic_get_cpumask(struct gic_chip_data *gic)
 	void __iomem *base = gic_data_dist_base(gic);
 	u32 mask, i;
 
+	/**
+	 * 前32个中断，不能指定其目标CPU
+	 * 因此GIC_DIST_TARGETn寄存器为只读，代表当前CPU位于哪个端口上。
+	 */
 	for (i = mask = 0; i < 32; i += 4) {
+		/**
+		 * Interrupt Processor Targets Registers
+		 */
 		mask = readl_relaxed(base + GIC_DIST_TARGET + i);
+		/**
+		 * 实际上，GIC-V2只支持8个CPU
+		 * 因此只有其中8位是有效的
+		 */
 		mask |= mask >> 16;
 		mask |= mask >> 8;
 		if (mask)
@@ -456,6 +493,7 @@ static void gic_cpu_if_up(struct gic_chip_data *gic)
 	bypass = readl(cpu_base + GIC_CPU_CTRL);
 	bypass &= GICC_DIS_BYPASS_MASK;
 
+	//打开中断
 	writel_relaxed(bypass | mode | GICC_ENABLE, cpu_base + GIC_CPU_CTRL);
 }
 
@@ -467,19 +505,29 @@ static void __init gic_dist_init(struct gic_chip_data *gic)
 	unsigned int gic_irqs = gic->gic_irqs;
 	void __iomem *base = gic_data_dist_base(gic);
 
+	/**
+	 * Distributor Control Register用来控制全局的中断forward情况。
+	 * 写入0表示Distributor不向CPU interface发送中断请求信号，也就disable了全部的中断请求
+	 */
 	writel_relaxed(GICD_DISABLE, base + GIC_DIST_CTRL);
 
 	/*
 	 * Set all global interrupts to this CPU only.
 	 */
+	//获得当前CPU的硬件编号
 	cpumask = gic_get_cpumask(gic);
 	cpumask |= cpumask << 8;
 	cpumask |= cpumask << 16;
+	//设置所有中断仅仅送到当前CPU
 	for (i = 32; i < gic_irqs; i += 4)
 		writel_relaxed(cpumask, base + GIC_DIST_TARGET + i * 4 / 4);
 
+	/**
+	 * 配置默认值，如中断类型
+	 */
 	gic_dist_config(base, gic_irqs, NULL);
 
+	//打开中断
 	writel_relaxed(GICD_ENABLE, base + GIC_DIST_CTRL);
 }
 
@@ -495,7 +543,7 @@ static void gic_cpu_init(struct gic_chip_data *gic)
 	 * because any nested/secondary GICs do not directly interface
 	 * with the CPU(s).
 	 */
-	if (gic == &gic_data[0]) {
+	if (gic == &gic_data[0]) {/* 只需要初始化一次，针对root GIC即可 */
 		/*
 		 * Get what the GIC says our CPU mask is.
 		 */
@@ -514,6 +562,10 @@ static void gic_cpu_init(struct gic_chip_data *gic)
 
 	gic_cpu_config(dist_base, NULL);
 
+	/**
+	 * 中断优先级0xa0，GICC_INT_PRI_THRESHOLD = 0xf0
+	 * OK
+	 */
 	writel_relaxed(GICC_INT_PRI_THRESHOLD, base + GIC_CPU_PRIMASK);
 	gic_cpu_if_up(gic);
 }
@@ -889,6 +941,10 @@ void __init gic_init_physaddr(struct device_node *node)
 #define gic_init_physaddr(node)  do { } while (0)
 #endif
 
+/**
+ * 创建IRQ number和GIC hw interrupt ID之间映射关系的时候
+ * 需要调用该回调函数。
+ */
 static int gic_irq_domain_map(struct irq_domain *d, unsigned int irq,
 				irq_hw_number_t hw)
 {
@@ -899,12 +955,22 @@ static int gic_irq_domain_map(struct irq_domain *d, unsigned int irq,
 			chip = &gic_eoimode1_chip;
 	}
 
+	/**
+	 * SGI或者PPI和SPI最大的不同是per cpu的
+	 * SPI是所有CPU共享的，因此需要分配per cpu的内存
+	 * 设定一些per cpu的flag
+	 */
 	if (hw < 32) {
 		irq_set_percpu_devid(irq);
+		/**
+		 * 设定该中断描述符的irq chip和high level的handler
+		 */
 		irq_domain_set_info(d, irq, hw, chip, d->host_data,
 				    handle_percpu_devid_irq, NULL, NULL);
 		irq_set_status_flags(irq, IRQ_NOAUTOEN);
+	/* SPI */
 	} else {
+		/* 默认handle_fasteoi_irq */
 		irq_domain_set_info(d, irq, hw, chip, d->host_data,
 				    handle_fasteoi_irq, NULL, NULL);
 		irq_set_probe(irq);
@@ -916,6 +982,9 @@ static void gic_irq_domain_unmap(struct irq_domain *d, unsigned int irq)
 {
 }
 
+/**
+ * 解析DT中的中断属性
+ */
 static int gic_irq_domain_xlate(struct irq_domain *d,
 				struct device_node *controller,
 				const u32 *intspec, unsigned int intsize,
@@ -925,16 +994,26 @@ static int gic_irq_domain_xlate(struct irq_domain *d,
 
 	if (d->of_node != controller)
 		return -EINVAL;
+	/**
+	 * interrupt specifier包括3个cell
+	 * 分别是interrupt type（0 表示SPI，1表示PPI）
+	 * interrupt number（对于PPI，范围是[0-15]，对于SPI，范围是[0-987]）
+	 * interrupt flag（触发方式）
+	 */
 	if (intsize < 3)
 		return -EINVAL;
 
 	/* Get the interrupt number and add 16 to skip over SGIs */
+	/**
+	 * GIC interrupt specifier中的interrupt number需要加上16
+	 */
 	*out_hwirq = intspec[1] + 16;
 
 	/* For SPIs, we need to add 16 more to get the GIC irq ID number */
 	if (!intspec[0])
 		*out_hwirq += 16;
 
+	/* 后三位是触发方式 */
 	*out_type = intspec[2] & IRQ_TYPE_SENSE_MASK;
 
 	return ret;
@@ -1038,6 +1117,7 @@ static void __init __gic_init_bases(unsigned int gic_nr, int irq_start,
 	 * Find out how many interrupts are supported.
 	 * The GIC only supports up to 1020 interrupt sources.
 	 */
+	/* GIC支持的中断数量 */
 	gic_irqs = readl_relaxed(gic_data_dist_base(gic) + GIC_DIST_CTR) & 0x1f;
 	gic_irqs = (gic_irqs + 1) * 32;
 	if (gic_irqs > 1020)
@@ -1198,9 +1278,11 @@ gic_of_init(struct device_node *node, struct device_node *parent)
 	if (WARN_ON(!node))
 		return -ENODEV;
 
+	//映射GIC Distributor的寄存器地址空间
 	dist_base = of_iomap(node, 0);
 	WARN(!dist_base, "unable to map gic dist registers\n");
 
+	//映射GIC CPU interface的寄存器地址空间
 	cpu_base = of_iomap(node, 1);
 	WARN(!cpu_base, "unable to map gic cpu registers\n");
 
@@ -1211,9 +1293,14 @@ gic_of_init(struct device_node *node, struct device_node *parent)
 	if (gic_cnt == 0 && !gic_check_eoimode(node, &cpu_base))
 		static_key_slow_dec(&supports_deactivate);
 
+	/**
+	 * 如果每个CPU可以通过统一的寄存器地址去访问各自的专属寄存器
+	 * 那么就不用设置cpu-offset
+	 */
 	if (of_property_read_u32(node, "cpu-offset", &percpu_offset))
 		percpu_offset = 0;
 
+	//主初始化函数
 	__gic_init_bases(gic_cnt, -1, dist_base, cpu_base, percpu_offset, node);
 	if (!gic_cnt)
 		gic_init_physaddr(node);
-- 
2.25.1

