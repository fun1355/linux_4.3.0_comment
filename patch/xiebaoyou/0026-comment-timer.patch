From b3f4a5fc40a5fcd72fdf005ecc6da172810d815d Mon Sep 17 00:00:00 2001
From: "xie.baoyou" <scxby@163.com>
Date: Mon, 23 Oct 2017 15:31:59 +0800
Subject: [PATCH] =?UTF-8?q?[comment-timer]=20=E6=97=B6=E9=92=9F=E6=A1=86?=
 =?UTF-8?q?=E6=9E=B6=E7=AC=AC=E4=BA=8C=E9=83=A8=E5=88=86?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 include/linux/clockchips.h   |  50 ++++++++++++++++++
 include/linux/clocksource.h  |  29 ++++++++++
 include/linux/cpuidle.h      |   4 ++
 include/linux/hrtimer.h      |   3 ++
 include/linux/timecounter.h  |  20 +++++++
 kernel/time/clockevents.c    |  69 ++++++++++++++++++++++--
 kernel/time/clocksource.c    |  84 ++++++++++++++++++++++++++---
 kernel/time/hrtimer.c        |  11 ++++
 kernel/time/tick-broadcast.c |  88 ++++++++++++++++++++++++++++--
 kernel/time/tick-common.c    | 100 ++++++++++++++++++++++++++++++++++-
 kernel/time/tick-oneshot.c   |  10 +++-
 kernel/time/tick-sched.c     |  13 +++++
 kernel/time/tick-sched.h     |   6 +++
 kernel/time/timecounter.c    |   6 +++
 14 files changed, 473 insertions(+), 20 deletions(-)
 mode change 100644 => 100755 include/linux/clockchips.h
 mode change 100644 => 100755 include/linux/cpuidle.h
 mode change 100644 => 100755 include/linux/hrtimer.h
 mode change 100644 => 100755 include/linux/timecounter.h
 mode change 100644 => 100755 kernel/time/clockevents.c
 mode change 100644 => 100755 kernel/time/clocksource.c
 mode change 100644 => 100755 kernel/time/tick-broadcast.c
 mode change 100644 => 100755 kernel/time/tick-oneshot.c
 mode change 100644 => 100755 kernel/time/tick-sched.h
 mode change 100644 => 100755 kernel/time/timecounter.c

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
old mode 100644
new mode 100755
index bdcf358d..90c8c8d2
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -42,8 +42,18 @@ enum clock_event_state {
 /*
  * Clock event features
  */
+/**
+ * 具备产生周期性event的能力
+ */
 # define CLOCK_EVT_FEAT_PERIODIC	0x000001
+/**
+ * 具备产生oneshot类型event的能力
+ */
 # define CLOCK_EVT_FEAT_ONESHOT		0x000002
+/**
+ * 功能强大的硬件
+ * 竟然支持以纳秒为单位设置超时周期
+ */
 # define CLOCK_EVT_FEAT_KTIME		0x000004
 
 /*
@@ -52,7 +62,14 @@ enum clock_event_state {
  * - Clockevent source stops in C3 State and needs broadcast support.
  * - Local APIC timer is used as a dummy device.
  */
+/**
+ * CPU进入C3睡眠状态时，该时钟会失效
+ */
 # define CLOCK_EVT_FEAT_C3STOP		0x000008
+/**
+ * 时钟设备只是一个摆设
+ * apic local timer有这个标志
+ */
 # define CLOCK_EVT_FEAT_DUMMY		0x000010
 
 /*
@@ -64,6 +81,9 @@ enum clock_event_state {
 /*
  * Clockevent device is based on a hrtimer for broadcast
  */
+/**
+ * 基于高精度时钟来实现
+ */
 # define CLOCK_EVT_FEAT_HRTIMER		0x000080
 
 /**
@@ -96,19 +116,40 @@ enum clock_event_state {
  * @list:		list head for the management code
  * @owner:		module reference
  */
+/**
+ * 定时器设备描述符
+ */
 struct clock_event_device {
+	/**
+	 * 时钟的定时中断处理函数
+	 * 如tick_handle_periodic
+	 */
 	void			(*event_handler)(struct clock_event_device *);
+	/** 
+	 * 控制下一次event产生的时间点
+	 * set_next_event以cycles为单位
+	 * set_next_ktime以ktime(纳秒)为单位
+	 */
 	int			(*set_next_event)(unsigned long evt, struct clock_event_device *);
 	int			(*set_next_ktime)(ktime_t expires, struct clock_event_device *);
+	/**
+	 * 下一次触发clock event的时间
+	 */
 	ktime_t			next_event;
 	u64			max_delta_ns;
 	u64			min_delta_ns;
+	/* 类似于clocksource */
 	u32			mult;
 	u32			shift;
 	enum clock_event_state	state_use_accessors;
+	/**
+	 * 底层硬件的属性
+	 * 如CLOCK_EVT_FEAT_PERIODIC
+	 */
 	unsigned int		features;
 	unsigned long		retries;
 
+	/* 设置为不同的工作状态 */
 	int			(*set_state_periodic)(struct clock_event_device *);
 	int			(*set_state_oneshot)(struct clock_event_device *);
 	int			(*set_state_oneshot_stopped)(struct clock_event_device *);
@@ -118,13 +159,22 @@ struct clock_event_device {
 	void			(*broadcast)(const struct cpumask *mask);
 	void			(*suspend)(struct clock_event_device *);
 	void			(*resume)(struct clock_event_device *);
+	/**
+	 * 硬件支持的最大cycles值
+	 */
 	unsigned long		min_delta_ticks;
 	unsigned long		max_delta_ticks;
 
 	const char		*name;
+	/* 类似于clocksource */
 	int			rating;
+	/* 使用的IRQ number */
 	int			irq;
+	/* 该clock event device附着在哪一个CPU core上 */
 	int			bound_on;
+	/**
+	 * 为哪些CPU服务
+	 */
 	const struct cpumask	*cpumask;
 	struct list_head	list;
 	struct module		*owner;
diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 1567204d..1cd8030c 100755
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -63,30 +63,53 @@ struct module;
  * @resume:		resume function for the clocksource, if necessary
  * @owner:		module reference, must be set by clocksource in modules
  */
+/**
+ * 时钟源描述符，用于提供free running的硬件
+ */
 struct clocksource {
 	/*
 	 * Hotpath data, fits in a single cache line when the
 	 * clocksource itself is cacheline aligned.
 	 */
+	/* 读取硬件时间戳 */
 	cycle_t (*read)(struct clocksource *cs);
+	/* 时钟的有效位，超过这些位就溢出了 */
 	cycle_t mask;
+	/* ns = ((u64) cycles * mult) >> shift */
 	u32 mult;
 	u32 shift;
+	/* 能够休眠的最大时间，超过此时间cycles会溢出 */
 	u64 max_idle_ns;
 	u32 maxadj;
+
+	/**
+	 * 下面这些字段没那么重要，可以放在下一个cacheline
+	 */
 #ifdef CONFIG_ARCH_CLOCKSOURCE_DATA
 	struct arch_clocksource_data archdata;
 #endif
 	u64 max_cycles;
 	const char *name;
+	/**
+	 * 将时钟挂到全局链表中
+	 */
 	struct list_head list;
+	/**
+	 * 描述时钟的质量，好货还是歪货
+	 */
 	int rating;
 	/**
 	 * 启用时钟源
 	 */
 	int (*enable)(struct clocksource *cs);
 	void (*disable)(struct clocksource *cs);
+	/**
+	 * 标志和特性
+	 */
 	unsigned long flags;
+	/**
+	 * 电源管理相关
+	 */
 	void (*suspend)(struct clocksource *cs);
 	void (*resume)(struct clocksource *cs);
 
@@ -98,6 +121,9 @@ struct clocksource {
 	cycle_t wd_last;
 #endif
 	struct module *owner;
+/**
+ * 频繁访问的数据，前面一部分集中放在一个缓存行
+ */
 } ____cacheline_aligned;
 
 /*
@@ -107,6 +133,9 @@ struct clocksource {
 #define CLOCK_SOURCE_MUST_VERIFY		0x02
 
 #define CLOCK_SOURCE_WATCHDOG			0x10
+/**
+ * 对高精度时钟有用???
+ */
 #define CLOCK_SOURCE_VALID_FOR_HRES		0x20
 #define CLOCK_SOURCE_UNSTABLE			0x40
 /**
diff --git a/include/linux/cpuidle.h b/include/linux/cpuidle.h
old mode 100644
new mode 100755
index 786ad326..9b3023bf
--- a/include/linux/cpuidle.h
+++ b/include/linux/cpuidle.h
@@ -63,6 +63,10 @@ struct cpuidle_state {
 
 /* Idle State Flags */
 #define CPUIDLE_FLAG_COUPLED	(0x02) /* state applies to multiple cpus */
+/**
+ * CPU IDLE进入此状态，其时钟也被停止
+ * 需要广播唤醒此CPU
+ */
 #define CPUIDLE_FLAG_TIMER_STOP (0x04)  /* timer is stopped on this state */
 
 #define CPUIDLE_DRIVER_FLAGS_MASK (0xFFFF0000)
diff --git a/include/linux/hrtimer.h b/include/linux/hrtimer.h
old mode 100644
new mode 100755
index 76dd4f0d..cc7ed3e6
--- a/include/linux/hrtimer.h
+++ b/include/linux/hrtimer.h
@@ -329,6 +329,9 @@ static inline void timerfd_clock_was_set(void) { }
 #endif
 extern void hrtimers_resume(void);
 
+/**
+ * 每CPU的Tick设备
+ */
 DECLARE_PER_CPU(struct tick_device, tick_cpu_device);
 
 
diff --git a/include/linux/timecounter.h b/include/linux/timecounter.h
old mode 100644
new mode 100755
index 4382035a..b7312b3d
--- a/include/linux/timecounter.h
+++ b/include/linux/timecounter.h
@@ -36,9 +36,17 @@
  * @mult:		cycle to nanosecond multiplier
  * @shift:		cycle to nanosecond divisor (power of two)
  */
+/**
+ * 时间戳描述符
+ */
 struct cyclecounter {
+	/**
+	 * 获取当前的counter value，单位是cycle
+	 */
 	cycle_t (*read)(const struct cyclecounter *cc);
+	/* 有效位 */
 	cycle_t mask;
+	/* 转换成ns需要的乘积因子和右移因子 */
 	u32 mult;
 	u32 shift;
 };
@@ -61,9 +69,21 @@ struct cyclecounter {
  * @mask:		bit mask for maintaining the 'frac' field
  * @frac:		accumulated fractional nanoseconds
  */
+/**
+ * 纳秒表
+ */
 struct timecounter {
+	/**
+	 * 所使用的cycles表
+	 */
 	const struct cyclecounter *cc;
+	/**
+	 * 上次访问时的cycles
+	 */
 	cycle_t cycle_last;
+	/**
+	 * 当前的纳秒值
+	 */
 	u64 nsec;
 	u64 mask;
 	u64 frac;
diff --git a/kernel/time/clockevents.c b/kernel/time/clockevents.c
old mode 100644
new mode 100755
index a9b76a40..8427aed8
--- a/kernel/time/clockevents.c
+++ b/kernel/time/clockevents.c
@@ -21,7 +21,13 @@
 #include "tick-internal.h"
 
 /* The registered clock event devices */
+/**
+ * 当前可用的定时器设备
+ */
 static LIST_HEAD(clockevent_devices);
+/**
+ * 由于种种原因，无法进入active list
+ */
 static LIST_HEAD(clockevents_released);
 /* Protection for the above */
 static DEFINE_RAW_SPINLOCK(clockevents_lock);
@@ -277,18 +283,24 @@ static int clockevents_program_min_delta(struct clock_event_device *dev)
  *
  * Returns 0 on success, -ETIME when the retry loop failed.
  */
+/**
+ * 向硬件写入一个最小的时间超时值
+ */
 static int clockevents_program_min_delta(struct clock_event_device *dev)
 {
 	unsigned long long clc;
 	int64_t delta;
 
+	/* 硬件允许的最小的时间点 */
 	delta = dev->min_delta_ns;
+	/* 下一次要触发event的时间点 */
 	dev->next_event = ktime_add_ns(ktime_get(), delta);
 
 	if (clockevent_state_shutdown(dev))
 		return 0;
 
 	dev->retries++;
+	/* 转换成cycles后写入硬件 */
 	clc = ((unsigned long long) delta * dev->mult) >> dev->shift;
 	return dev->set_next_event((unsigned long) clc, dev);
 }
@@ -303,6 +315,10 @@ static int clockevents_program_min_delta(struct clock_event_device *dev)
  *
  * Returns 0 on success, -ETIME when the event is in the past.
  */
+/**
+ * 对定时器设备进行编程
+ * 设置其超时事件
+ */
 int clockevents_program_event(struct clock_event_device *dev, ktime_t expires,
 			      bool force)
 {
@@ -310,13 +326,17 @@ int clockevents_program_event(struct clock_event_device *dev, ktime_t expires,
 	int64_t delta;
 	int rc;
 
-	if (unlikely(expires.tv64 < 0)) {
+	if (unlikely(expires.tv64 < 0)) {/* 参数错误 */
 		WARN_ON_ONCE(1);
 		return -ETIME;
 	}
 
+	/**
+	 * 设定下一次触发clock event的时间
+	 */
 	dev->next_event = expires;
 
+	/* 定时器被关闭了 */
 	if (clockevent_state_shutdown(dev))
 		return 0;
 
@@ -325,17 +345,27 @@ int clockevents_program_event(struct clock_event_device *dev, ktime_t expires,
 		  clockevent_get_state(dev));
 
 	/* Shortcut for clockevent devices that can deal with ktime. */
+	/* chip driver支持使用ktime的设定 */
 	if (dev->features & CLOCK_EVT_FEAT_KTIME)
+		/* 直接调用set_next_ktime就搞定了 */
 		return dev->set_next_ktime(expires, dev);
 
+	/**
+	 * “正常”的clock event device
+	 * 转换成cycle这样的单位
+	 */
 	delta = ktime_to_ns(ktime_sub(expires, ktime_get()));
-	if (delta <= 0)
+	if (delta <= 0)/* 时间已经过去了 */
+		/* 那就设置一个最小间隔，或者返回错误 */
 		return force ? clockevents_program_min_delta(dev) : -ETIME;
 
+	/* 不能超过硬件支持的最大值 */
 	delta = min(delta, (int64_t) dev->max_delta_ns);
 	delta = max(delta, (int64_t) dev->min_delta_ns);
 
+	/* 将时间转换为CYCLES */
 	clc = ((unsigned long long) delta * dev->mult) >> dev->shift;
+	/* 调用驱动的回调，设置硬件 */
 	rc = dev->set_next_event((unsigned long) clc, dev);
 
 	return (rc && force) ? clockevents_program_min_delta(dev) : rc;
@@ -446,6 +476,9 @@ EXPORT_SYMBOL_GPL(clockevents_unbind_device);
  * clockevents_register_device - register a clock event device
  * @dev:	device to register
  */
+/**
+ * 注册定时器设备
+ */
 void clockevents_register_device(struct clock_event_device *dev)
 {
 	unsigned long flags;
@@ -453,14 +486,20 @@ void clockevents_register_device(struct clock_event_device *dev)
 	/* Initialize state to DETACHED */
 	clockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);
 
+	/**
+	 * cpumask指明该设备为哪一个CPU工作，如果没有设定
+	 */
 	if (!dev->cpumask) {
+		/* 多核的情况下报个警 */
 		WARN_ON(num_possible_cpus() > 1);
+		/* 设置为本CPU工作 */
 		dev->cpumask = cpumask_of(smp_processor_id());
 	}
 
 	raw_spin_lock_irqsave(&clockevents_lock, flags);
 
 	list_add(&dev->list, &clockevent_devices);
+	/* 通知TICK层，有新设备了 */
 	tick_check_new_device(dev);
 	clockevents_notify_released();
 
@@ -468,10 +507,14 @@ void clockevents_register_device(struct clock_event_device *dev)
 }
 EXPORT_SYMBOL_GPL(clockevents_register_device);
 
+/**
+ * 初始化定时器设备
+ */
 void clockevents_config(struct clock_event_device *dev, u32 freq)
 {
 	u64 sec;
 
+	/* 周期性的，没啥好配置的了 */
 	if (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))
 		return;
 
@@ -480,14 +523,18 @@ void clockevents_config(struct clock_event_device *dev, u32 freq)
 	 * to 10 minutes for hardware which can program more than
 	 * 32bit ticks so we still get reasonable conversion values.
 	 */
+	/* 硬件timer的最大cycles */
 	sec = dev->max_delta_ticks;
+	/* 除以频率就是秒数 */
 	do_div(sec, freq);
+	/* 多么熟悉的代码，与clocksource类似 */
 	if (!sec)
 		sec = 1;
 	else if (sec > 600 && dev->max_delta_ticks > UINT_MAX)
 		sec = 600;
 
 	clockevents_calc_mult_shift(dev, freq, sec);
+	/* 将cycles转换为ns，得到最大和最小的ns */
 	dev->min_delta_ns = cev_delta2ns(dev->min_delta_ticks, dev, false);
 	dev->max_delta_ns = cev_delta2ns(dev->max_delta_ticks, dev, true);
 }
@@ -565,6 +612,9 @@ void clockevents_handle_noop(struct clock_event_device *dev)
  * Called from various tick functions with clockevents_lock held and
  * interrupts disabled.
  */
+/**
+ * 切换定时设备
+ */
 void clockevents_exchange_device(struct clock_event_device *old,
 				 struct clock_event_device *new)
 {
@@ -572,14 +622,18 @@ void clockevents_exchange_device(struct clock_event_device *old,
 	 * Caller releases a clock event device. We queue it into the
 	 * released list and do a notify add later.
 	 */
-	if (old) {
+	if (old) {/* 旧的clock event device要被替换掉 */
 		module_put(old->owner);
+		/* 将其模式设定为CLOCK_EVT_STATE_DETACHED */
 		clockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);
+		/* 从全局clock event device链表中摘下来 */
 		list_del(&old->list);
+		/* 挂入clockevents_released链表 */
 		list_add(&old->list, &clockevents_released);
 	}
 
 	if (new) {
+		/* 竟然不是CLOCK_EVT_STATE_DETACHED状态? */
 		BUG_ON(!clockevent_state_detached(new));
 		clockevents_shutdown(new);
 	}
@@ -734,13 +788,16 @@ static int __init tick_init_sysfs(void)
 {
 	int cpu;
 
+	/* 遍历各个CPU的clock event device */
 	for_each_possible_cpu(cpu) {
 		struct device *dev = &per_cpu(tick_percpu_dev, cpu);
 		int err;
 
 		dev->id = cpu;
 		dev->bus = &clockevents_subsys;
+		/* 把clock event device注册到系统中 */
 		err = device_register(dev);
+		/* 创建属性文件 */
 		if (!err)
 			err = device_create_file(dev, &dev_attr_current_device);
 		if (!err)
@@ -748,14 +805,20 @@ static int __init tick_init_sysfs(void)
 		if (err)
 			return err;
 	}
+	/* 别忘了还有广播设备 */
 	return tick_broadcast_init_sysfs();
 }
 
+/**
+ * 定时器子系统sysfs接口初始化
+ */
 static int __init clockevents_init_sysfs(void)
 {
+	/* 注册clock event这种bus type */
 	int err = subsys_system_register(&clockevents_subsys, NULL);
 
 	if (!err)
+		/* tick子系统的sysfs初始化 */
 		err = tick_init_sysfs();
 	return err;
 }
diff --git a/kernel/time/clocksource.c b/kernel/time/clocksource.c
old mode 100644
new mode 100755
index 3a38775b..23817ff3
--- a/kernel/time/clocksource.c
+++ b/kernel/time/clocksource.c
@@ -103,6 +103,9 @@ clocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 maxsec)
 static struct clocksource *curr_clocksource;
 static LIST_HEAD(clocksource_list);
 static DEFINE_MUTEX(clocksource_mutex);
+/**
+ * 用户强制指定的时钟源名称
+ */
 static char override_name[CS_NAME_LEN];
 static int finished_booting;
 
@@ -529,6 +532,11 @@ static struct clocksource *clocksource_find_best(bool oneshot, bool skipcur)
 {
 	struct clocksource *cs;
 
+	/**
+	 * 启动过程中，clocksource在反复注册
+	 * 这个时候就不要选择时钟了。
+	 * 如果时钟列表为空，也不要选择了。
+	 */
 	if (!finished_booting || list_empty(&clocksource_list))
 		return NULL;
 
@@ -537,11 +545,15 @@ static struct clocksource *clocksource_find_best(bool oneshot, bool skipcur)
 	 * mode is active, we pick the highres valid clocksource with
 	 * the best rating.
 	 */
+	/* 遍历所有时钟，找最优 */
 	list_for_each_entry(cs, &clocksource_list, list) {
+		/* 略过当前时钟，准备退休?? */
 		if (skipcur && cs == curr_clocksource)
 			continue;
+		/* ?? */
 		if (oneshot && !(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES))
 			continue;
+		/* 链表里面的时钟是按精度降序排列的 */
 		return cs;
 	}
 	return NULL;
@@ -553,32 +565,40 @@ static void __clocksource_select(bool skipcur)
 	struct clocksource *best, *cs;
 
 	/* Find the best suitable clocksource */
+	/* 把最好的时钟拉出来 */
 	best = clocksource_find_best(oneshot, skipcur);
 	if (!best)
 		return;
 
 	/* Check for the override clocksource. */
+	/**
+	 * 如果用户强制指定了clocksource
+	 * 这里遍历链表，找到匹配的那个时钟
+	 */
 	list_for_each_entry(cs, &clocksource_list, list) {
-		if (skipcur && cs == curr_clocksource)
+		if (skipcur && cs == curr_clocksource)/* 跳过当前时钟 */
 			continue;
-		if (strcmp(cs->name, override_name) != 0)
+		if (strcmp(cs->name, override_name) != 0)/* 不是指定的那个时钟 */
 			continue;
 		/*
 		 * Check to make sure we don't switch to a non-highres
 		 * capable clocksource if the tick code is in oneshot
 		 * mode (highres or nohz)
 		 */
+		/* 强制指定的不可用 */
 		if (!(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES) && oneshot) {
 			/* Override clocksource cannot be used. */
 			pr_warn("Override clocksource %s is not HRT compatible - cannot switch while in HRT/NOHZ mode\n",
 				cs->name);
+			/* 清除用户指定的时钟源 */
 			override_name[0] = 0;
 		} else
 			/* Override clocksource can be used. */
-			best = cs;
+			best = cs;/* 找到了，就是它 */
 		break;
 	}
 
+	/* 通知timekeeping模块 */
 	if (curr_clocksource != best && !timekeeping_notify(best)) {
 		pr_info("Switched to clocksource %s\n", best->name);
 		curr_clocksource = best;
@@ -593,6 +613,9 @@ static void __clocksource_select(bool skipcur)
  * Select the clocksource with the best rating, or the clocksource,
  * which is selected by userspace override.
  */
+/**
+ * 从所有clocksource中选择一个最优的
+ */
 static void clocksource_select(void)
 {
 	return __clocksource_select(false);
@@ -667,6 +690,11 @@ void __clocksource_update_freq_scale(struct clocksource *cs, u32 scale, u32 freq
 	 * Default clocksources are *special* and self-define their mult/shift.
 	 * But, you're not special, so you should specify a freq value.
 	 */
+	/**
+	 * 上层调用者比较懒，没有计算mult/shift 
+	 * 把这个活交给底层了
+	 * shit......
+	 */
 	if (freq) {
 		/*
 		 * Calc the maximum number of seconds which we can run before
@@ -677,22 +705,40 @@ void __clocksource_update_freq_scale(struct clocksource *cs, u32 scale, u32 freq
 		 * clocksource with mask >= 40-bit and f >= 4GHz. That maps to
 		 * ~ 0.06ppm granularity for NTP.
 		 */
+		/* 时钟的最大有效位 */
 		sec = cs->mask;
+		/* 算出最大的秒数 */
 		do_div(sec, freq);
 		do_div(sec, scale);
-		if (!sec)
+		if (!sec)/* 不到1秒的精度，不好玩 */
 			sec = 1;
+		/**
+		 * 看来精度有点高，第二个条件
+		 * 为了避免算出来的mult太小，误差加大，这里做一下限制
+		 */
 		else if (sec > 600 && cs->mask > UINT_MAX)
 			sec = 600;
 
+		/* 计算几个参数，其实最好是驱动里面指定 */
 		clocks_calc_mult_shift(&cs->mult, &cs->shift, freq,
 				       NSEC_PER_SEC / scale, sec * scale);
 	}
 	/*
 	 * Ensure clocksources that have large 'mult' values don't overflow
-	 * when adjusted.
+	 *  when adjusted.
+	 */
+	/**
+	 * mult成员11％的值
+	 * 将这个值作为浮动范围
+	 * NTP在调整的时候，不要超过这个范围
 	 */
 	cs->maxadj = clocksource_max_adjustment(cs);
+	/**
+	 * 比较微妙的代码，看懂了吗?
+	 * 这里是防止11%的浮动值引起整形溢出
+	 * 所以以损失精度的方法来防止溢出
+	 * 阅读时要注意 cycles、mult、shift的位数
+	 */
 	while (freq && ((cs->mult + cs->maxadj < cs->mult)
 		|| (cs->mult - cs->maxadj > cs->mult))) {
 		cs->mult >>= 1;
@@ -708,6 +754,7 @@ void __clocksource_update_freq_scale(struct clocksource *cs, u32 scale, u32 freq
 		"timekeeping: Clocksource %s might overflow on 11%% adjustment\n",
 		cs->name);
 
+	/* 计算max_idle_ns */
 	clocksource_update_max_deferment(cs);
 
 	pr_info("%s: mask: 0x%llx max_cycles: 0x%llx, max_idle_ns: %lld ns\n",
@@ -726,16 +773,24 @@ EXPORT_SYMBOL_GPL(__clocksource_update_freq_scale);
  * This *SHOULD NOT* be called directly! Please use the
  * clocksource_register_hz() or clocksource_register_khz helper functions.
  */
+/**
+ * 注册clocksource
+ */
 int __clocksource_register_scale(struct clocksource *cs, u32 scale, u32 freq)
 {
 
 	/* Initialize mult/shift and max_idle_ns */
+	/* 计算时钟的几个重要参数 */
 	__clocksource_update_freq_scale(cs, scale, freq);
 
 	/* Add clocksource to the clocksource list */
+	/* 保护对clock sourct list这一全局共享资源的访问 */
 	mutex_lock(&clocksource_mutex);
+	/* 将该clock source按照rating的顺序插入到全局clock source list中 */
 	clocksource_enqueue(cs);
+	/* 处理clock source watchdog相关的内容 */
 	clocksource_enqueue_watchdog(cs);
+	/* 选择一个合适的clock source */
 	clocksource_select();
 	mutex_unlock(&clocksource_mutex);
 	return 0;
@@ -772,16 +827,19 @@ static int clocksource_unbind(struct clocksource *cs)
 	 * I really can't convince myself to support this on hardware
 	 * designed by lobotomized monkeys.
 	 */
-	if (clocksource_is_watchdog(cs))
+	if (clocksource_is_watchdog(cs))/* watchdog使用的基准时钟，不能注销 */
 		return -EBUSY;
 
-	if (cs == curr_clocksource) {
+	if (cs == curr_clocksource) {/* 注销当前clock source */
 		/* Select and try to install a replacement clock source */
+		/* 选择一个新的当前clock source */
 		clocksource_select_fallback();
-		if (curr_clocksource == cs)
+		if (curr_clocksource == cs)/* 系统中的唯一的clock source，不能注销 */
 			return -EBUSY;
 	}
+	/* 将该节点从watchdog的全局列表中取下来 */
 	clocksource_dequeue_watchdog(cs);
+	/* 将该节点从clocksource的全局列表中取下来 */
 	list_del_init(&cs->list);
 	return 0;
 }
@@ -790,6 +848,9 @@ static int clocksource_unbind(struct clocksource *cs)
  * clocksource_unregister - remove a registered clocksource
  * @cs:	clocksource to be unregistered
  */
+/**
+ * 注销clocksource
+ */
 int clocksource_unregister(struct clocksource *cs)
 {
 	int ret = 0;
@@ -961,10 +1022,17 @@ static struct device device_clocksource = {
 
 static int __init init_clocksource_sysfs(void)
 {
+	/**
+	 * 创建sysfs接口
+	 */
 	int error = subsys_system_register(&clocksource_subsys, NULL);
 
 	if (!error)
+		/* 将设备注册到设备模型中 */
 		error = device_register(&device_clocksource);
+	/**
+	 * 创建设备属性文件
+	 */
 	if (!error)
 		error = device_create_file(
 				&device_clocksource,
diff --git a/kernel/time/hrtimer.c b/kernel/time/hrtimer.c
index acd4d23d..daf10ddf 100755
--- a/kernel/time/hrtimer.c
+++ b/kernel/time/hrtimer.c
@@ -692,6 +692,7 @@ static void hrtimer_switch_to_hres(void)
 {
 	struct hrtimer_cpu_base *base = this_cpu_ptr(&hrtimer_bases);
 
+	/* 先切时钟*/
 	if (tick_init_highres()) {
 		printk(KERN_WARNING "Could not switch to high resolution "
 				    "mode on CPU %d\n", base->cpu);
@@ -830,6 +831,9 @@ void unlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)
  * Note: This only updates the timer expiry value and does not requeue
  * the timer.
  */
+/**
+ * 将高精度定时器挂回红黑树
+ */
 u64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)
 {
 	u64 orun = 1;
@@ -1301,6 +1305,9 @@ static void __hrtimer_run_queues(struct hrtimer_cpu_base *cpu_base, ktime_t now)
  * High resolution timer interrupt
  * Called with interrupts disabled
  */
+/**
+ * 高精度定时器的中断处理函数
+ */
 void hrtimer_interrupt(struct clock_event_device *dev)
 {
 	struct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);
@@ -1425,7 +1432,11 @@ void hrtimer_run_queues(void)
 	 * there only sets the check bit in the tick_oneshot code,
 	 * otherwise we might deadlock vs. xtime_lock.
 	 */
+	/**
+	 * 高精度时钟已经就绪
+	 */
 	if (tick_check_oneshot_change(!hrtimer_is_hres_enabled())) {
+		/* 那就切过去了*/
 		hrtimer_switch_to_hres();
 		return;
 	}
diff --git a/kernel/time/tick-broadcast.c b/kernel/time/tick-broadcast.c
old mode 100644
new mode 100755
index f6aae797..ed4abcc2
--- a/kernel/time/tick-broadcast.c
+++ b/kernel/time/tick-broadcast.c
@@ -28,11 +28,27 @@
  * timer stops in C3 state.
  */
 
+/**
+ * 进行tick广播的设备
+ */
 static struct tick_device tick_broadcast_device;
+/**
+ * 在周期性TICK模式下
+ * 哪些CPU可能需要TICK广播
+ */
 static cpumask_var_t tick_broadcast_mask;
+/**
+ * 在周期性TICK模式下
+ * 哪些CPU可能进入了IDLE
+ */
 static cpumask_var_t tick_broadcast_on;
 static cpumask_var_t tmpmask;
 static DEFINE_RAW_SPINLOCK(tick_broadcast_lock);
+/**
+ * 是否强制使用tick广播，而不是用本地时钟
+ * 用于x86
+ * 参见http://lwn.net/Articles/286432/
+ */
 static int tick_broadcast_forced;
 
 #ifdef CONFIG_TICK_ONESHOT
@@ -71,35 +87,54 @@ static void tick_broadcast_start_periodic(struct clock_event_device *bc)
 static bool tick_check_broadcast_device(struct clock_event_device *curdev,
 					struct clock_event_device *newdev)
 {
-	if ((newdev->features & CLOCK_EVT_FEAT_DUMMY) ||
-	    (newdev->features & CLOCK_EVT_FEAT_PERCPU) ||
-	    (newdev->features & CLOCK_EVT_FEAT_C3STOP))
+	if ((newdev->features & CLOCK_EVT_FEAT_DUMMY) ||/* 这种设备当然不行 */
+	    (newdev->features & CLOCK_EVT_FEAT_PERCPU) ||/* 每CPU设备也不行 */
+	    (newdev->features & CLOCK_EVT_FEAT_C3STOP))/* 本来就是为了解决C3STOP的 */
 		return false;
 
+	/* 比原来的还不如 */
 	if (tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT &&
 	    !(newdev->features & CLOCK_EVT_FEAT_ONESHOT))
 		return false;
 
+	/* 比较精度，如果精度不行，也不要 */
 	return !curdev || newdev->rating > curdev->rating;
 }
 
 /*
  * Conditionally install/replace broadcast device
  */
+/**
+ * 安装/替换系统中broadcast tick device
+ */
 void tick_install_broadcast_device(struct clock_event_device *dev)
 {
+	/* 获取当前的broadcast tick device */
 	struct clock_event_device *cur = tick_broadcast_device.evtdev;
 
+	/* 时钟设备是否有能力作为广播设备 */
 	if (!tick_check_broadcast_device(cur, dev))
 		return;
 
+	/* 对模块引用 */
 	if (!try_module_get(dev->owner))
 		return;
 
+	/**
+	 * 用新的clock event device来替换旧的
+	 * 因此需要将旧的clock event device（如果存在的话）从active 队列中摘除
+	 * 并设定CLOCK_EVT_MODE_UNUSED状态
+	 * 挂入released clockevent队列。
+	 * 对于新的clockevent device，需要设定为CLOCK_EVT_MODE_SHUTDOWN状态。
+	 */
 	clockevents_exchange_device(cur, dev);
 	if (cur)
 		cur->event_handler = clockevents_handle_noop;
 	tick_broadcast_device.evtdev = dev;
+	/**
+	 * 只要有一个需要TICK广播
+	 * 那么我们就要启动broadcast tick device的运作，使之进入周期性tick的mode。
+	 */
 	if (!cpumask_empty(tick_broadcast_mask))
 		tick_broadcast_start_periodic(dev);
 	/*
@@ -110,7 +145,14 @@ void tick_install_broadcast_device(struct clock_event_device *dev)
 	 * notification the systems stays stuck in periodic mode
 	 * forever.
 	 */
+	/**
+	 * broadcast tick设备的clock event device具备one shot能力
+	 */
 	if (dev->features & CLOCK_EVT_FEAT_ONESHOT)
+		/**
+		 * 异步通知到各个CPU
+		 * 看是否有机会让per cpu tick device也切换到one shot的状态
+		 */
 		tick_clock_notify();
 }
 
@@ -155,6 +197,9 @@ static void tick_device_setup_broadcast_func(struct clock_event_device *dev)
  * Check, if the device is disfunctional and a place holder, which
  * needs to be handled by the broadcast device.
  */
+/**
+ * 检查当前per cpu tick device的HW timer的特性并确定是否要启用broadcast tick设备
+ */
 int tick_device_uses_broadcast(struct clock_event_device *dev, int cpu)
 {
 	struct clock_event_device *bc = tick_broadcast_device.evtdev;
@@ -169,10 +214,17 @@ int tick_device_uses_broadcast(struct clock_event_device *dev, int cpu)
 	 * operated from the broadcast device and is a placeholder for
 	 * the cpu local device.
 	 */
+	 /**
+	  * 如果有CLOCK_EVT_FEAT_DUMMY标志
+	  */
 	if (!tick_device_is_functional(dev)) {
+		/* 工作于周期性模式 */
 		dev->event_handler = tick_handle_periodic;
+		/* 由广播设备生成时钟 */
 		tick_device_setup_broadcast_func(dev);
+		/* 把自己加入到广播接收方 */
 		cpumask_set_cpu(cpu, tick_broadcast_mask);
+		/* 使广播设备开始工作 */
 		if (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)
 			tick_broadcast_start_periodic(bc);
 		else
@@ -183,9 +235,12 @@ int tick_device_uses_broadcast(struct clock_event_device *dev, int cpu)
 		 * Clear the broadcast bit for this cpu if the
 		 * device is not power state affected.
 		 */
+		/* 本地时钟可以搞定一切 */
 		if (!(dev->features & CLOCK_EVT_FEAT_C3STOP))
+			/* 把当前CPU从掩码中清除，表示本CPU不需要接收广播 */
 			cpumask_clear_cpu(cpu, tick_broadcast_mask);
 		else
+			/* 否则 设定发送广播的函数为tick_broadcast */
 			tick_device_setup_broadcast_func(dev);
 
 		/*
@@ -265,9 +320,13 @@ static bool tick_do_broadcast(struct cpumask *mask)
 	/*
 	 * Check, if the current cpu is in the mask
 	 */
+	/**
+	 * 是否本cpu也需要broadcast tick 设备的服务
+	 */
 	if (cpumask_test_cpu(cpu, mask)) {
 		struct clock_event_device *bc = tick_broadcast_device.evtdev;
 
+		/* 本CPU的事件处理由上层调用者处理 */
 		cpumask_clear_cpu(cpu, mask);
 		/*
 		 * We only run the local handler, if the broadcast
@@ -281,19 +340,22 @@ static bool tick_do_broadcast(struct cpumask *mask)
 		 *         local_handler()
 		 *	     expire_hrtimers()
 		 */
+		/* 本CPU是高精度时钟，那么不用在这里调用TICK回调 */
 		local = !(bc->features & CLOCK_EVT_FEAT_HRTIMER);
 	}
 
-	if (!cpumask_empty(mask)) {
+	if (!cpumask_empty(mask)) {/* 除了本CPU，还有其他CPU需要广播 */
 		/*
 		 * It might be necessary to actually check whether the devices
 		 * have different broadcast functions. For now, just use the
 		 * one of the first device. This works as long as we have this
 		 * misfeature only on x86 (lapic)
 		 */
+		/* 那就真的向其他CPU广播TICK了 */
 		td = &per_cpu(tick_cpu_device, cpumask_first(mask));
 		td->evtdev->broadcast(mask);
 	}
+	/* 如果返回true，则上层调用本CPU的事件回调 */
 	return local;
 }
 
@@ -303,6 +365,11 @@ static bool tick_do_broadcast(struct cpumask *mask)
  */
 static bool tick_do_periodic_broadcast(void)
 {
+	/**
+	 * cpu_online_mask记录了on line的cpu
+	 * tick_broadcast_mask记录了申请broad cast服务的cpu
+	 * 因此只需要处理那些CPU处于online状态并且申请了broad cast服务的cpu
+	 */
 	cpumask_and(tmpmask, cpu_online_mask, tick_broadcast_mask);
 	return tick_do_broadcast(tmpmask);
 }
@@ -310,6 +377,9 @@ static bool tick_do_periodic_broadcast(void)
 /*
  * Event handler for periodic broadcast ticks
  */
+/**
+ * broadcast device的事件处理函数
+ */
 static void tick_handle_periodic_broadcast(struct clock_event_device *dev)
 {
 	struct tick_device *td = this_cpu_ptr(&tick_cpu_device);
@@ -323,9 +393,13 @@ static void tick_handle_periodic_broadcast(struct clock_event_device *dev)
 		return;
 	}
 
+	/**
+	 * 向其他核广播TICK事件
+	 */
 	bc_local = tick_do_periodic_broadcast();
 
-	if (clockevent_state_oneshot(dev)) {
+	if (clockevent_state_oneshot(dev)) {/* one shot模式 */
+		/* 设置下次时钟触发时间 */
 		ktime_t next = ktime_add(dev->next_event, tick_period);
 
 		clockevents_program_event(dev, next, true);
@@ -337,6 +411,10 @@ static void tick_handle_periodic_broadcast(struct clock_event_device *dev)
 	 * tick_broadcast_lock because the handler might deadlock when
 	 * trying to switch to oneshot mode.
 	 */
+	/**
+	 * 如果本CPU也需要处理tick回调
+	 * 则调用本地TICK处理函数
+	 */
 	if (bc_local)
 		td->evtdev->event_handler(td->evtdev);
 }
diff --git a/kernel/time/tick-common.c b/kernel/time/tick-common.c
index 3e815bd9..1ca1c278 100755
--- a/kernel/time/tick-common.c
+++ b/kernel/time/tick-common.c
@@ -32,7 +32,13 @@ DEFINE_PER_CPU(struct tick_device, tick_cpu_device);
 /*
  * Tick next event: keeps track of the tick time
  */
+/**
+ * 周期性TICK的下一个周期
+ */
 ktime_t tick_next_period;
+/**
+ * 周期性TICK的周期间隔
+ */
 ktime_t tick_period;
 
 /*
@@ -49,6 +55,10 @@ ktime_t tick_period;
  *    at it will take over and keep the time keeping alive.  The handover
  *    procedure also covers cpu hotplug.
  */
+/**
+ * 哪一个CPU上的 tick设备作为全局tick
+ * 更新jiffies，更新系统的wall time，更新系统的平均负载
+ */
 int tick_do_timer_cpu __read_mostly = TICK_DO_TIMER_BOOT;
 
 /*
@@ -62,14 +72,20 @@ struct tick_device *tick_get_device(int cpu)
 /**
  * tick_is_oneshot_available - check for a oneshot capable event device
  */
+/**
+ * 检查本地TICK设备是否适合进入one shot模式
+ */
 int tick_is_oneshot_available(void)
 {
 	struct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);
 
+	/* 设备是否支持one shot模式 */
 	if (!dev || !(dev->features & CLOCK_EVT_FEAT_ONESHOT))
 		return 0;
+	/* C3时，设备也不会停止，这个太好了 */
 	if (!(dev->features & CLOCK_EVT_FEAT_C3STOP))
 		return 1;
+	/* 如果C3时会停止，那就得看广播设备是否可用 */
 	return tick_broadcast_oneshot_available();
 }
 
@@ -103,11 +119,15 @@ static void tick_periodic(int cpu)
 /*
  * Event handler for periodic ticks
  */
+/**
+ * 周期性时钟中断回调
+ */
 void tick_handle_periodic(struct clock_event_device *dev)
 {
 	int cpu = smp_processor_id();
 	ktime_t next = dev->next_event;
 
+	/* 周期性tick中要处理的内容 */
 	tick_periodic(cpu);
 
 #if defined(CONFIG_HIGH_RES_TIMERS) || defined(CONFIG_NO_HZ_COMMON)
@@ -120,6 +140,10 @@ void tick_handle_periodic(struct clock_event_device *dev)
 		return;
 #endif
 
+	/**
+	 * 不是one shot模式
+	 * 就不必对one shot进行编程了
+	 */
 	if (!clockevent_state_oneshot(dev))
 		return;
 	for (;;) {
@@ -127,8 +151,10 @@ void tick_handle_periodic(struct clock_event_device *dev)
 		 * Setup the next period for devices, which do not have
 		 * periodic mode:
 		 */
+		/* 计算下一个周期性tick触发的时间 */
 		next = ktime_add(next, tick_period);
 
+		/* 设定下一个clock event触发的时间 */
 		if (!clockevents_program_event(dev, next, false))
 			return;
 		/*
@@ -140,7 +166,9 @@ void tick_handle_periodic(struct clock_event_device *dev)
 		 * which then will increment time, possibly causing
 		 * the loop to trigger again and again.
 		 */
+		/* 竟然设置失败了，应该是下一个中断又到期了 */
 		if (timekeeping_valid_for_hres())
+			/* 补充执行一下，然后设置再下一个定时器 */
 			tick_periodic(cpu);
 	}
 }
@@ -148,16 +176,24 @@ void tick_handle_periodic(struct clock_event_device *dev)
 /*
  * Setup the device for a periodic tick
  */
+/**
+ * 将时钟设备设置为周期性模式
+ */
 void tick_setup_periodic(struct clock_event_device *dev, int broadcast)
 {
+	/**
+	 * 对于tick device ，设定event handler为tick_handle_periodic
+	 * 对于broadcast tick device，event handler被设定为tick_handle_periodic_broadcast
+	 */
 	tick_set_periodic_handler(dev, broadcast);
 
 	/* Broadcast setup ? */
 	if (!tick_device_is_functional(dev))
 		return;
 
-	if ((dev->features & CLOCK_EVT_FEAT_PERIODIC) &&
-	    !tick_broadcast_oneshot_active()) {
+	if ((dev->features & CLOCK_EVT_FEAT_PERIODIC) && /* 设备支持周期性模式 */
+	    !tick_broadcast_oneshot_active()) {/* 并且目前one shot还不可用 */
+	    	/* 直接设定为周期性模式即可 */
 		clockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);
 	} else {
 		unsigned long seq;
@@ -165,14 +201,22 @@ void tick_setup_periodic(struct clock_event_device *dev, int broadcast)
 
 		do {
 			seq = read_seqbegin(&jiffies_lock);
+			/**
+			 * 获取下一个周期性tick触发的时间
+			 */
 			next = tick_next_period;
 		} while (read_seqretry(&jiffies_lock, seq));
 
+		/**
+		 * 模式设定
+		 */
 		clockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);
 
 		for (;;) {
+			/* 事件编程 */
 			if (!clockevents_program_event(dev, next, false))
 				return;
+			/* 计算下一个周期性tick触发的时间 */
 			next = ktime_add(next, tick_period);
 		}
 	}
@@ -196,11 +240,19 @@ static void tick_setup_device(struct tick_device *td,
 		 * If no cpu took the do_timer update, assign it to
 		 * this cpu:
 		 */
+		/**
+		 * 前系统中没有global tick设备
+		 */
 		if (tick_do_timer_cpu == TICK_DO_TIMER_BOOT) {
+			/**
+			 * 那么可以考虑选择该tick设备作为global设备
+			 * 进行系统时间和jiffies的更新
+			 */
 			if (!tick_nohz_full_cpu(cpu))
 				tick_do_timer_cpu = cpu;
 			else
 				tick_do_timer_cpu = TICK_DO_TIMER_NONE;
+			/* 设置这两个变量，全局tick可以开工了 */
 			tick_next_period = ktime_get();
 			tick_period = ktime_set(0, NSEC_PER_SEC / HZ);
 		}
@@ -208,20 +260,30 @@ static void tick_setup_device(struct tick_device *td,
 		/*
 		 * Startup in periodic mode first.
 		 */
+		/**
+		 * 最初都设置为周期性的
+		 */
 		td->mode = TICKDEV_MODE_PERIODIC;
 	} else {
+		/**
+		 * 旧的clockevent设备就要退居二线了
+		 * 将其handler修改为clockevents_handle_noop
+		 */
 		handler = td->evtdev->event_handler;
 		next_event = td->evtdev->next_event;
 		td->evtdev->event_handler = clockevents_handle_noop;
 	}
 
+	/* 终于修成正果了 */
 	td->evtdev = newdev;
 
 	/*
 	 * When the device is not per cpu, pin the interrupt to the
 	 * current cpu:
 	 */
+	/* 当然还没有在该CPU上产生中断 */
 	if (!cpumask_equal(newdev->cpumask, cpumask))
+		/* 让中断亲和到本CPU */
 		irq_set_affinity(newdev->irq, cpumask);
 
 	/*
@@ -231,12 +293,23 @@ static void tick_setup_device(struct tick_device *td,
 	 * way. This function also returns !=0 when we keep the
 	 * current active broadcast state for this CPU.
 	 */
+	/* 广播设备，不能修改它的模式 */
 	if (tick_device_uses_broadcast(newdev, cpu))
 		return;
 
 	if (td->mode == TICKDEV_MODE_PERIODIC)
+		/**
+		 * 如果底层的clock event device支持periodic模式
+		 * 那么直接调用clockevents_set_mode设定模式就OK了
+		 */
 		tick_setup_periodic(newdev, 0);
 	else
+		/**
+		 * 如果底层的clock event device不支持periodic模式
+		 * 而tick device目前是周期性tick mode
+		 * 那么要稍微复杂一些
+		 * 需要用clock event device的one shot模式来实现周期性tick
+		 */
 		tick_setup_oneshot(newdev, handler, next_event);
 }
 
@@ -304,6 +377,10 @@ bool tick_check_replacement(struct clock_event_device *curdev,
  * Check, if the new registered device should be used. Called with
  * clockevents_lock held and interrupts disabled.
  */
+/**
+ * 在注册时钟设备的时候，调用此函数
+ * 检查是否将其初始化为Tick设备
+ */
 void tick_check_new_device(struct clock_event_device *newdev)
 {
 	struct clock_event_device *curdev;
@@ -311,17 +388,28 @@ void tick_check_new_device(struct clock_event_device *newdev)
 	int cpu;
 
 	cpu = smp_processor_id();
+	/* 获取当前cpu的tick device */
 	td = &per_cpu(tick_cpu_device, cpu);
 	curdev = td->evtdev;
 
 	/* cpu local device ? */
+	/**
+	 * 这是本CPU可用的tick设备吗
+	 * 检查其CPU掩码
+	 * 以及中断亲和性
+	 */
 	if (!tick_check_percpu(curdev, newdev, cpu))
+		/* 如果不是，那么看能不能做为广播设备 */
 		goto out_bc;
 
 	/* Preference decision */
+	/**
+	 * 看看是不是比目前的tick设备更好
+	 */
 	if (!tick_check_preferred(curdev, newdev))
 		goto out_bc;
 
+	/* 增加模块引用计数 */
 	if (!try_module_get(newdev->owner))
 		return;
 
@@ -330,12 +418,20 @@ void tick_check_new_device(struct clock_event_device *newdev)
 	 * device. If the current device is the broadcast device, do
 	 * not give it back to the clockevents layer !
 	 */
+	/**
+	 * 当前Tick设备是广播设备
+	 */
 	if (tick_is_broadcast_device(curdev)) {
+		/* 把广播设备关闭 */
 		clockevents_shutdown(curdev);
+		/* 防止clockevents_exchange_device将其从链表中摘除 */
 		curdev = NULL;
 	}
+	/* 通知clockevent layer */
 	clockevents_exchange_device(curdev, newdev);
+	/* 启动新设备 */
 	tick_setup_device(td, newdev, cpu, cpumask_of(cpu));
+	/* 设备支持one shot */
 	if (newdev->features & CLOCK_EVT_FEAT_ONESHOT)
 		tick_oneshot_notify();
 	return;
diff --git a/kernel/time/tick-oneshot.c b/kernel/time/tick-oneshot.c
old mode 100644
new mode 100755
index b5134465..0220a0b4
--- a/kernel/time/tick-oneshot.c
+++ b/kernel/time/tick-oneshot.c
@@ -24,6 +24,9 @@
 /**
  * tick_program_event
  */
+/**
+ * 对高精度时钟进行编程，触发下一次中断
+ */
 int tick_program_event(ktime_t expires, int force)
 {
 	struct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);
@@ -78,9 +81,10 @@ int tick_switch_to_oneshot(void (*handler)(struct clock_event_device *))
 	struct tick_device *td = this_cpu_ptr(&tick_cpu_device);
 	struct clock_event_device *dev = td->evtdev;
 
-	if (!dev || !(dev->features & CLOCK_EVT_FEAT_ONESHOT) ||
-		    !tick_device_is_functional(dev)) {
+	if (!dev || !(dev->features & CLOCK_EVT_FEAT_ONESHOT) ||/* 不支持one shot */
+		    !tick_device_is_functional(dev)) {/* 设备是dummy */
 
+		/* 那还切个屁，打印警告后退出吧 */
 		printk(KERN_INFO "Clockevents: "
 		       "could not switch to one-shot mode:");
 		if (!dev) {
@@ -95,9 +99,11 @@ int tick_switch_to_oneshot(void (*handler)(struct clock_event_device *))
 		return -EINVAL;
 	}
 
+	/* 先把时钟切过来 */
 	td->mode = TICKDEV_MODE_ONESHOT;
 	dev->event_handler = handler;
 	clockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);
+	/* 通知其他核，将TICK也切到one shot模式 */
 	tick_broadcast_switch_to_oneshot();
 	return 0;
 }
diff --git a/kernel/time/tick-sched.c b/kernel/time/tick-sched.c
index 3846a0eb..7b2d4ae5 100755
--- a/kernel/time/tick-sched.c
+++ b/kernel/time/tick-sched.c
@@ -826,6 +826,9 @@ static void __tick_nohz_idle_enter(struct tick_sched *ts)
  *  to sleep.
  * - rcu_idle_exit() before the first use of RCU after the CPU is woken up.
  */
+/**
+ * 在进入idle前，停止掉周期性sched timer Tick时钟
+ */
 void tick_nohz_idle_enter(void)
 {
 	struct tick_sched *ts;
@@ -935,6 +938,9 @@ void tick_nohz_idle_exit(void)
 /*
  * The nohz low res interrupt handler
  */
+/**
+ * No-HZ低精度中断处理
+ */
 static void tick_nohz_handler(struct clock_event_device *dev)
 {
 	struct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);
@@ -1062,6 +1068,9 @@ void tick_irq_enter(void)
  * We rearm the timer until we get disabled by the idle code.
  * Called with interrupts disabled.
  */
+/**
+ * 高精度时钟模式下，由此定时器模拟TICK
+ */
 static enum hrtimer_restart tick_sched_timer(struct hrtimer *timer)
 {
 	struct tick_sched *ts =
@@ -1171,6 +1180,10 @@ void tick_oneshot_notify(void)
  * mode, because high resolution timers are disabled (either compile
  * or runtime). Called with interrupts disabled.
  */
+/**
+ * 在时钟软中断中调用
+ * 周期性的检测是否可以切换到oneshot mode
+ */
 int tick_check_oneshot_change(int allow_nohz)
 {
 	struct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);
diff --git a/kernel/time/tick-sched.h b/kernel/time/tick-sched.h
old mode 100644
new mode 100755
index a4a8d4e9..2627bd93
--- a/kernel/time/tick-sched.h
+++ b/kernel/time/tick-sched.h
@@ -4,12 +4,18 @@
 #include <linux/hrtimer.h>
 
 enum tick_device_mode {
+	/* 周期性模式 */
 	TICKDEV_MODE_PERIODIC,
+	/* one shot模式 */
 	TICKDEV_MODE_ONESHOT,
 };
 
+/**
+ * Tick设备描述符
+ */
 struct tick_device {
 	struct clock_event_device *evtdev;
+	/* 工作模式，如TICKDEV_MODE_PERIODIC */
 	enum tick_device_mode mode;
 };
 
diff --git a/kernel/time/timecounter.c b/kernel/time/timecounter.c
old mode 100644
new mode 100755
index 4687b310..d40d2e92
--- a/kernel/time/timecounter.c
+++ b/kernel/time/timecounter.c
@@ -18,6 +18,9 @@
 #include <linux/export.h>
 #include <linux/timecounter.h>
 
+/**
+ * 初始化一个纳秒表
+ */
 void timecounter_init(struct timecounter *tc,
 		      const struct cyclecounter *cc,
 		      u64 start_tstamp)
@@ -62,6 +65,9 @@ static u64 timecounter_read_delta(struct timecounter *tc)
 	return ns_offset;
 }
 
+/**
+ * 
+ */
 u64 timecounter_read(struct timecounter *tc)
 {
 	u64 nsec;
-- 
2.25.1

